<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Libre Antenne</title>
    <meta
      name="description"
      content="Le chaos en direct : un refuge sans filtre pour drogués, marginaux, alcooliques, gamers et esprits libres."
    />
    <meta name="keywords" content="radio libre, libre antenne, talk show en direct, discord audio, streaming communautaire" />
    <meta name="robots" content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1" />
    <meta name="googlebot" content="index, follow" />
    <meta name="bingbot" content="index, follow" />
    <meta name="referrer" content="no-referrer-when-downgrade" />
    <meta name="author" content="Libre Antenne" />
    <meta name="publisher" content="Libre Antenne" />
    <meta name="theme-color" content="#020617" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta name="application-name" content="Libre Antenne" />
    <meta name="apple-mobile-web-app-title" content="Libre Antenne" />
    <link rel="canonical" href="https://libre-antenne.xyz/" />
    <link rel="alternate" href="https://libre-antenne.xyz/" hreflang="fr-FR" />
    <link rel="manifest" href="/site.webmanifest" />
    <link rel="icon" type="image/svg+xml" href="/icons/icon-192.svg" />
    <link rel="apple-touch-icon" sizes="192x192" href="/icons/icon-192.svg" />
    <link rel="dns-prefetch" href="https://fonts.googleapis.com" />
    <link rel="dns-prefetch" href="https://fonts.gstatic.com" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      rel="preload"
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap"
      as="style"
      onload="this.onload=null;this.rel='stylesheet'"
    />
    <noscript>
      <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap"
        rel="stylesheet"
      />
    </noscript>
    <meta property="og:type" content="website" />
    <meta property="og:locale" content="fr_FR" />
    <meta property="og:url" content="https://libre-antenne.xyz/" />
    <meta property="og:site_name" content="Libre Antenne" />
    <meta property="og:title" content="Libre Antenne · Radio libre et streaming communautaire" />
    <meta
      property="og:description"
      content="Libre Antenne diffuse en continu les voix du salon Discord : un espace sans filtre pour les esprits libres, les joueurs et les noctambules."
    />
    <meta property="og:image" content="https://libre-antenne.xyz/icons/icon-512.png" />
    <meta property="og:image:alt" content="Illustration du direct communautaire Libre Antenne" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:site" content="@libreantenne" />
    <meta name="twitter:creator" content="@libreantenne" />
    <meta name="twitter:title" content="Libre Antenne · Radio libre et streaming communautaire" />
    <meta
      name="twitter:description"
      content="Rejoins le flux audio Libre Antenne pour partager ta voix en direct et écouter la communauté."
    />
    <meta name="twitter:image" content="https://libre-antenne.xyz/icons/icon-512.png" />
    <script src="https://cdn.tailwindcss.com?plugins=forms,typography,aspect-ratio"></script>
    <script type="application/ld+json">
      {
        "@context": "https://schema.org",
        "@type": "BroadcastService",
        "name": "Libre Antenne",
        "description": "Flux audio communautaire en direct diffusé depuis Discord, libre d'accès et sans filtre.",
        "url": "https://libre-antenne.xyz/",
        "areaServed": "FR",
        "inLanguage": "fr-FR",
        "provider": {
          "@type": "Organization",
          "name": "Libre Antenne",
          "url": "https://libre-antenne.xyz/"
        },
        "broadcastDisplayName": "Libre Antenne – Direct Discord",
        "broadcastFrequency": "Streaming en ligne",
        "sameAs": [
          "https://discord.com/",
          "https://twitter.com/libreantenne"
        ]
      }
    </script>
    <script>
      tailwind.config = {
        theme: {
          extend: {
            fontFamily: {
              sans: ['Inter', 'system-ui', 'sans-serif'],
            },
            boxShadow: {
              glow: '0 0 50px rgba(129, 140, 248, 0.35)',
            },
          },
        },
      };
    </script>
    <style>
      body {
        font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      }

      .speaker-card {
        opacity: 0;
        transform: translateY(24px) scale(0.97);
        animation: speaker-fade-in 1.25s cubic-bezier(0.16, 1, 0.3, 1) forwards;
        will-change: transform, opacity;
        transition: opacity 0.4s ease, transform 0.4s ease;
      }

      .speaker-card[data-state='idle'] {
        opacity: 0.92;
      }

      .speaker-card[data-state='speaking'] {
        opacity: 1;
      }

      @keyframes speaker-fade-in {
        0% {
          opacity: 0;
          transform: translateY(24px) scale(0.97);
        }

        35% {
          opacity: 0.55;
          transform: translateY(14px) scale(0.985);
        }

        70% {
          opacity: 0.9;
          transform: translateY(4px) scale(1.01);
        }

        100% {
          opacity: 1;
          transform: translateY(0) scale(1);
        }
      }

      @keyframes player-eq {
        0%,
        100% {
          transform: scaleY(0.45);
          opacity: 0.6;
        }

        50% {
          transform: scaleY(1);
          opacity: 1;
        }
      }

      .audio-wave span {
        animation: player-eq 1.2s ease-in-out infinite;
        transform-origin: center bottom;
        display: inline-block;
        width: 0.3rem;
        border-radius: 9999px;
      }

      .audio-wave span:nth-child(2) {
        animation-delay: 0.2s;
      }

      .audio-wave span:nth-child(3) {
        animation-delay: 0.4s;
      }

      .audio-wave span:nth-child(4) {
        animation-delay: 0.6s;
      }

      .mic-meter {
        position: relative;
        height: 0.6rem;
        border-radius: 9999px;
        background: rgba(148, 163, 184, 0.18);
        overflow: hidden;
      }

      .mic-meter-bar {
        position: absolute;
        inset: 0;
        width: 0%;
        background: linear-gradient(90deg, rgba(129, 140, 248, 0.9), rgba(236, 72, 153, 0.95));
        box-shadow: 0 0 30px rgba(236, 72, 153, 0.4);
        transition: width 0.18s cubic-bezier(0.16, 1, 0.3, 1);
      }
    </style>
  </head>
  <body class="min-h-screen bg-slate-950 text-slate-100 antialiased">
    <div id="app" class="min-h-screen"></div>

    <script type="module">
      import { h, render, Fragment } from 'https://esm.sh/preact@10.19.2';
      import { useCallback, useEffect, useLayoutEffect, useMemo, useRef, useState } from 'https://esm.sh/preact@10.19.2/hooks';
      import Chart from 'https://esm.sh/chart.js@4.4.2/auto';
      import {
        Activity,
        AlertCircle,
        BadgeCheck,
        ArrowLeft,
        ArrowRight,
        CalendarDays,
        Clock3,
        Coffee,
        Coins,
        CreditCard,
        Headphones,
        Menu,
        Mic,
        MicOff,
        MonitorPlay,
        Pause,
        Play,
        RefreshCcw,
        ShieldCheck,
        ShoppingBag,
        Shirt,
        Search,
        Sparkles,
        Truck,
        Users,
        Wallet,
        MessageSquare,
        Video,
        Volume,
        Volume1,
        Volume2,
        VolumeX,
        X,
      } from 'https://esm.sh/lucide-preact@0.428.0?deps=preact@10.19.2';
      import htm from 'https://esm.sh/htm@3.1.1?deps=preact@10.19.2';

      const html = htm.bind(h);

      Chart.defaults.font.family = "'Inter', system-ui, sans-serif";
      Chart.defaults.color = '#e2e8f0';
      Chart.defaults.borderColor = 'rgba(148, 163, 184, 0.25)';

      const STATUS_LABELS = {
        connecting: {
          label: 'Connexion…',
          ring: 'bg-amber-400/20 text-amber-200 border-amber-400/50',
          dot: 'bg-amber-300',
        },
        connected: {
          label: '',
          srLabel: 'Flux en cours',
          Icon: Activity,
          ring: 'bg-emerald-400/15 text-emerald-200 border-emerald-400/40',
          dot: 'bg-emerald-300',
        },
        reconnecting: {
          label: 'Reconnexion…',
          ring: 'bg-sky-400/15 text-sky-200 border-sky-400/40',
          dot: 'bg-sky-300',
        },
        error: {
          label: 'Hors ligne',
          ring: 'bg-rose-500/20 text-rose-100 border-rose-400/50',
          dot: 'bg-rose-300',
        },
      };

      const formatDuration = (ms) => {
        if (!ms || Number.isNaN(ms)) return '';
        const totalSeconds = Math.max(0, Math.round(ms / 1000));
        const minutes = Math.floor(totalSeconds / 60);
        const seconds = totalSeconds % 60;
        if (minutes === 0) return `${seconds}s`;
        if (minutes >= 60) {
          const hours = Math.floor(minutes / 60);
          const remMinutes = minutes % 60;
          return `${hours}h ${remMinutes}m`;
        }
        return `${minutes}m ${seconds.toString().padStart(2, '0')}s`;
      };

      const formatRelative = (timestamp, now) => {
        if (!timestamp) return '—';
        const diff = Math.max(0, now - timestamp);
        if (diff < 30_000) return 'il y a quelques secondes';
        if (diff < 5 * 60_000) return 'il y a moins de 5 min';
        return new Date(timestamp).toLocaleTimeString('fr-FR', {
          hour: '2-digit',
          minute: '2-digit',
        });
      };

      const parseRangeValue = (value) => {
        if (value instanceof Date) {
          const time = value.getTime();
          return Number.isNaN(time) ? null : time;
        }
        if (typeof value === 'number' && Number.isFinite(value)) {
          return value;
        }
        if (typeof value === 'string') {
          const trimmed = value.trim();
          if (!trimmed) {
            return null;
          }
          const numeric = Number(trimmed);
          if (Number.isFinite(numeric)) {
            return numeric;
          }
          const parsed = Date.parse(trimmed);
          if (Number.isFinite(parsed)) {
            return parsed;
          }
        }
        return null;
      };

      const buildProfileHash = (userId, sinceMs, untilMs) => {
        if (!userId) {
          return '#/profil';
        }
        const base = `#/profil/${encodeURIComponent(userId)}`;
        const params = new URLSearchParams();
        if (Number.isFinite(sinceMs)) {
          params.set('since', String(Math.floor(sinceMs)));
        }
        if (Number.isFinite(untilMs)) {
          params.set('until', String(Math.floor(untilMs)));
        }
        const query = params.toString();
        return query ? `${base}?${query}` : base;
      };

      const TALK_WINDOW_OPTIONS = [5, 10, 15, 30, 60];
      const DEFAULT_WINDOW_MINUTES = TALK_WINDOW_OPTIONS.includes(15) ? 15 : TALK_WINDOW_OPTIONS[0];
      const HISTORY_RETENTION_MS = Math.max(
        (Math.max(...TALK_WINDOW_OPTIONS) + 5) * 60 * 1000,
        24 * 60 * 60 * 1000,
      );
      const HOURS_IN_DAY = 24;
      const MINUTE_MS = 60 * 1000;
      const HOUR_MS = 60 * MINUTE_MS;
      const DAY_MS = 24 * HOUR_MS;
      const FALLBACK_SEGMENT_MS = 1000;
      const DEFAULT_PROFILE_RANGE_MS = 24 * HOUR_MS;

      const sanitizeProfile = (raw = {}) => {
        const displayName = typeof raw.displayName === 'string' && raw.displayName.trim().length > 0 ? raw.displayName.trim() : null;
        const username = typeof raw.username === 'string' && raw.username.trim().length > 0 ? raw.username.trim() : null;
        const avatar = typeof raw.avatar === 'string' && raw.avatar.trim().length > 0 ? raw.avatar.trim() : null;
        return { displayName, username, avatar };
      };

      const mergeProfiles = (base = {}, incoming = {}) => {
        const sanitizedIncoming = sanitizeProfile(incoming);
        const sanitizedBase = sanitizeProfile(base);
        return {
          displayName: sanitizedIncoming.displayName ?? sanitizedBase.displayName ?? null,
          username: sanitizedIncoming.username ?? sanitizedBase.username ?? null,
          avatar: sanitizedIncoming.avatar ?? sanitizedBase.avatar ?? null,
        };
      };

      const trimSegments = (segments, now) => {
        const threshold = now - HISTORY_RETENTION_MS;
        return segments.filter((segment) => {
          const end = typeof segment.end === 'number' ? segment.end : now;
          return end >= threshold;
        });
      };

      const ensureOpenSegment = (segments, userId, startTime, profile) => {
        const safeStart = Number.isFinite(startTime) ? startTime : Date.now();
        const sanitizedProfile = sanitizeProfile(profile);
        let found = false;
        const next = segments.map((segment) => {
          if (segment.id === userId && segment.end == null) {
            found = true;
            return {
              ...segment,
              start: Number.isFinite(segment.start) ? Math.min(segment.start, safeStart) : safeStart,
              profile: mergeProfiles(segment.profile, sanitizedProfile),
            };
          }
          return segment;
        });
        if (!found) {
          return [
            ...next,
            {
              id: userId,
              start: safeStart,
              end: null,
              profile: sanitizedProfile,
            },
          ];
        }
        return next;
      };

      const closeOpenSegment = (segments, userId, endTime, profile, { createIfMissing = false } = {}) => {
        const safeEnd = Number.isFinite(endTime) ? endTime : Date.now();
        const sanitizedProfile = sanitizeProfile(profile);
        let closed = false;
        const next = segments.map((segment) => {
          if (segment.id === userId && segment.end == null) {
            closed = true;
            const boundedEnd = Math.max(safeEnd, Number.isFinite(segment.start) ? segment.start : safeEnd);
            return {
              ...segment,
              end: boundedEnd,
              profile: mergeProfiles(segment.profile, sanitizedProfile),
            };
          }
          return segment;
        });

        if (!closed && createIfMissing) {
          const fallbackStart = Math.max(0, safeEnd - FALLBACK_SEGMENT_MS);
          return [
            ...next,
            {
              id: userId,
              start: Math.min(fallbackStart, safeEnd),
              end: safeEnd,
              profile: sanitizedProfile,
            },
          ];
        }

        return next;
      };

      const sortSegments = (segments) => segments.slice().sort((a, b) => (a.start || 0) - (b.start || 0));

      const normalizeAnonymousSlot = (raw) => {
        if (!raw || typeof raw !== 'object') {
          return {
            occupied: false,
            alias: null,
            claimedAt: null,
            expiresAt: null,
            remainingMs: null,
            connectionPending: false,
            message: null,
          };
        }

        return {
          occupied: Boolean(raw.occupied),
          alias: typeof raw.alias === 'string' ? raw.alias : null,
          claimedAt: Number.isFinite(raw.claimedAt) ? raw.claimedAt : null,
          expiresAt: Number.isFinite(raw.expiresAt) ? raw.expiresAt : null,
          remainingMs: Number.isFinite(raw.remainingMs) ? raw.remainingMs : null,
          connectionPending: Boolean(raw.connectionPending),
          message: typeof raw.message === 'string' ? raw.message : null,
        };
      };

      const StatusBadge = ({ status, className = '' }) => {
        const config = STATUS_LABELS[status] ?? STATUS_LABELS.connecting;
        const rawLabel = typeof config.label === 'string' ? config.label : '';
        const trimmedLabel = rawLabel.trim();
        const srText = config.srLabel ?? (trimmedLabel ? trimmedLabel : 'Statut');
        return html`
          <div
            class=${`flex items-center gap-2 rounded-full border px-4 py-2 text-sm font-medium backdrop-blur ${config.ring} ${className}`}
            aria-label=${srText}
          >
            <span class=${`h-2.5 w-2.5 rounded-full shadow-md ${config.dot}`}></span>
            <span class="flex items-center gap-1">
              ${config.Icon ? html`<${config.Icon} class="h-4 w-4" aria-hidden="true" />` : null}
              <span class="sr-only">${srText}</span>
              ${trimmedLabel
                ? html`<span aria-hidden="true">${rawLabel}</span>`
                : null}
            </span>
          </div>
        `;
      };

      const useSmoothReorder = (ids) => {
        const containerRef = useRef(null);
        const positionsRef = useRef(new Map());

        useLayoutEffect(() => {
          if (typeof window === 'undefined') return;
          const container = containerRef.current;
          if (!container) return;

          const prefersReducedMotion = window.matchMedia?.('(prefers-reduced-motion: reduce)')?.matches;
          const elements = Array.from(container.querySelectorAll('[data-speaker-id]'));
          const nextPositions = new Map();

          for (const element of elements) {
            const id = element.getAttribute('data-speaker-id');
            if (!id) continue;
            nextPositions.set(id, element.getBoundingClientRect());
          }

          if (!prefersReducedMotion) {
            for (const element of elements) {
              const id = element.getAttribute('data-speaker-id');
              if (!id) continue;
              const previous = positionsRef.current.get(id);
              const current = nextPositions.get(id);
              if (!previous || !current) continue;
              const deltaX = previous.left - current.left;
              const deltaY = previous.top - current.top;
              if ((deltaX === 0 && deltaY === 0) || typeof element.animate !== 'function') continue;
              element.animate(
                [
                  { transform: `translate(${deltaX}px, ${deltaY}px)` },
                  { transform: 'translate(0, 0)' },
                ],
                {
                  duration: 1600,
                  easing: 'cubic-bezier(0.16, 1, 0.3, 1)',
                },
              );
            }
          }

          positionsRef.current = nextPositions;
        }, [ids.join('|')]);

        return containerRef;
      };

      const SpeakerCard = ({ speaker, now, cardId, onViewProfile }) => {
        const voiceState = speaker.voiceState ?? {};
        const isSpeaking = Boolean(speaker.isSpeaking);
        const duration = isSpeaking && speaker.startedAt ? formatDuration(now - speaker.startedAt) : null;
        const lastSpoke = !isSpeaking && speaker.lastSpokeAt ? formatRelative(speaker.lastSpokeAt, now) : null;

        const cardState = isSpeaking ? 'speaking' : 'idle';
        const cardAccentClass = isSpeaking
          ? 'border-fuchsia-400/60 bg-gradient-to-br from-indigo-500/20 via-slate-950 to-fuchsia-500/15'
          : 'border-white/10 bg-slate-950/75';

        const badgeConfig = (() => {
          if (isSpeaking) {
            return {
              srLabel: 'Intervention en cours',
              label: '',
              Icon: Activity,
              classes: 'bg-emerald-500 text-emerald-900',
              ping: true,
              dot: 'bg-emerald-800',
            };
          }
          if (voiceState.selfMute || voiceState.mute) {
            return {
              srLabel: 'Micro coupé',
              label: 'Muet',
              Icon: MicOff,
              classes: 'bg-slate-200/90 text-slate-900',
              ping: false,
              dot: 'bg-slate-900/70',
            };
          }
          if (voiceState.selfDeaf || voiceState.deaf) {
            return {
              srLabel: 'Casque coupé',
              label: 'Casque',
              Icon: Headphones,
              classes: 'bg-slate-200/90 text-slate-900',
              ping: false,
              dot: 'bg-slate-900/70',
            };
          }
          return {
            srLabel: 'À l’écoute',
            label: 'Écoute',
            Icon: Headphones,
            classes: 'bg-slate-200/90 text-slate-900',
            ping: false,
            dot: 'bg-slate-900/70',
          };
        })();

        const secondaryInfo = (() => {
          if (isSpeaking) {
            return {
              Icon: Activity,
              text: duration ? `Depuis ${duration}` : null,
              srLabel: duration
                ? `Intervention en cours depuis ${duration}`
                : 'Intervention en cours',
            };
          }
          if (lastSpoke) {
            return {
              Icon: Clock3,
              text: lastSpoke,
              srLabel: `Dernière intervention ${lastSpoke}`,
            };
          }
          return {
            Icon: Clock3,
            text: 'Pas encore intervenu',
            srLabel: 'Pas encore intervenu',
          };
        })();

        const { Icon: SecondaryIcon, text: secondaryText, srLabel: secondarySrLabel } = secondaryInfo;

        const voiceBadges = [];
        if (voiceState.selfMute || voiceState.mute) {
          voiceBadges.push({ key: 'mute', label: 'Muet', Icon: MicOff });
        }
        if (voiceState.selfDeaf || voiceState.deaf) {
          voiceBadges.push({ key: 'deaf', label: 'Casque off', Icon: Headphones });
        }
        if (voiceState.streaming) {
          voiceBadges.push({ key: 'stream', label: 'Partage', Icon: MonitorPlay });
        }
        if (voiceState.video) {
          voiceBadges.push({ key: 'video', label: 'Caméra', Icon: Video });
        }

        const safeDisplayName = typeof speaker.displayName === 'string' && speaker.displayName.trim().length
          ? speaker.displayName.trim()
          : 'Intervenant anonyme';
        const safeUsername = typeof speaker.username === 'string' && speaker.username.trim().length
          ? speaker.username.trim()
          : 'anonyme';

        const handleProfileClick = () => {
          if (typeof onViewProfile === 'function') {
            onViewProfile(speaker.id ?? cardId);
          }
        };

        const initials = safeDisplayName
          .split(/\s+/)
          .map((part) => part[0])
          .join('')
          .slice(0, 2)
          .toUpperCase();

        return html`
          <article
            class=${`speaker-card group relative overflow-hidden rounded-3xl border ${cardAccentClass} shadow-xl shadow-indigo-900/30 transition duration-300 hover:border-fuchsia-400/60 hover:shadow-glow`}
            data-state=${cardState}
            data-speaker-id=${cardId ?? speaker.id}
          >
            <div class="absolute -right-14 -top-14 h-32 w-32 rounded-full bg-fuchsia-500/40 blur-3xl transition-opacity duration-300 group-hover:opacity-100"></div>
            <button
              type="button"
              class="relative z-10 flex w-full items-center gap-5 rounded-3xl px-5 py-5 text-left focus:outline-none focus-visible:ring-2 focus-visible:ring-fuchsia-400/60 focus-visible:ring-offset-2 focus-visible:ring-offset-slate-950"
              onClick=${handleProfileClick}
            >
              <div class="relative h-20 w-20 flex-shrink-0">
                <div class="absolute inset-0 rounded-full bg-gradient-to-br from-fuchsia-500 via-indigo-400 to-sky-400 opacity-60 blur-xl transition group-hover:opacity-90"></div>
                ${speaker.avatar
                  ? html`<img
                      src=${speaker.avatar}
                      alt=${`Avatar de ${safeDisplayName}`}
                      class="relative h-20 w-20 rounded-full border-2 border-white/70 object-cover shadow-lg shadow-fuchsia-900/30"
                      loading="lazy"
                    />`
                  : html`<div class="relative flex h-20 w-20 items-center justify-center rounded-full border-2 border-white/70 bg-white/10 text-xl font-semibold text-white shadow-inner shadow-slate-950/40">
                      ${initials || '??'}
                    </div>`}
                <div
                  class=${`absolute -bottom-1 -right-1 flex items-center gap-1 rounded-full px-2 py-0.5 text-[0.6rem] font-semibold uppercase tracking-wider shadow-lg ${badgeConfig.classes}`}
                >
                  <span class="relative flex h-2 w-2">
                    <span
                      class=${`absolute inline-flex h-full w-full rounded-full ${
                        badgeConfig.ping ? 'animate-ping bg-emerald-200 opacity-75' : 'bg-slate-400/70 opacity-0'
                      }`}
                    ></span>
                    <span class=${`relative inline-flex h-2 w-2 rounded-full ${badgeConfig.dot}`}></span>
                  </span>
                  <span class="sr-only">${badgeConfig.srLabel}</span>
                  <${badgeConfig.Icon} class="h-3.5 w-3.5" aria-hidden="true" />
                  ${badgeConfig.label && badgeConfig.label.trim()
                    ? html`<span aria-hidden="true">${badgeConfig.label}</span>`
                    : null}
                </div>
              </div>
              <div class="relative flex flex-1 flex-col gap-2">
                <div class="flex flex-wrap items-baseline gap-2">
                  <h3 class="text-2xl font-semibold text-white">${safeDisplayName}</h3>
                  <span class="text-sm text-slate-300">@${safeUsername}</span>
                </div>
                <div class="flex flex-wrap items-center gap-3 text-xs text-slate-200">
                  <span class="flex items-center gap-1 rounded-full bg-white/10 px-3 py-1 backdrop-blur">
                    <${SecondaryIcon} class="h-3.5 w-3.5" aria-hidden="true" />
                    ${secondaryText ? html`<span>${secondaryText}</span>` : null}
                    <span class="sr-only">${secondarySrLabel}</span>
                  </span>
                </div>
                ${voiceBadges.length
                  ? html`<div class="flex flex-wrap items-center gap-2 text-slate-200/80">
                      ${voiceBadges.map(
                        ({ key, label, Icon }) => html`<span
                          key=${key}
                          class="inline-flex items-center gap-1 rounded-full bg-white/10 px-2.5 py-1 text-[0.65rem] font-medium uppercase tracking-[0.2em] text-slate-100 backdrop-blur transition hover:bg-white/15"
                          title=${label}
                          aria-label=${label}
                        >
                          <${Icon} class="h-3.5 w-3.5" aria-hidden="true" />
                          <span aria-hidden="true">${label}</span>
                        </span>`,
                      )}
                    </div>`
                  : null}
              </div>
            </button>
          </article>
        `;
      };
      const SpeakersSection = ({ speakers, now, onViewProfile }) => {
        const speakerIds = useMemo(() => speakers.map((speaker) => String(speaker.id ?? '')), [speakers]);
        const containerRef = useSmoothReorder(speakerIds);

        if (!speakers.length) {
          return html`
            <div class="mt-6 flex flex-col items-center justify-center gap-4 rounded-3xl border border-white/10 bg-black/40 px-8 py-12 text-center text-sm text-slate-300 backdrop-blur">
              <div class="flex h-14 w-14 items-center justify-center rounded-full bg-white/10 text-fuchsia-200">
                <${Users} class="h-7 w-7" aria-hidden="true" />
              </div>
              <p class="max-w-sm text-base text-slate-300">
                Aucun participant n'est connecté au salon vocal pour le moment. Dès qu’une personne rejoindra, elle apparaîtra ici.
              </p>
            </div>
          `;
        }

        return html`
          <div ref=${containerRef} class="mt-6 grid gap-6 sm:grid-cols-2">
            ${speakers.map((speaker) =>
              html`<${SpeakerCard}
                key=${speaker.id}
                speaker=${speaker}
                now=${now}
                cardId=${speaker.id}
                onViewProfile=${onViewProfile}
              />`,
            )}
          </div>
        `;
      };

      const DailyActivityChart = ({ history, now }) => {
        const scrollContainerRef = useRef(null);
        const currentBinRef = useRef(null);
        const setCurrentBinRef = useCallback((element) => {
          currentBinRef.current = element ?? null;
        }, []);

        const chart = useMemo(() => {
          const effectiveNow = Number.isFinite(now) ? now : Date.now();
          const anchor = new Date(effectiveNow);
          anchor.setHours(0, 0, 0, 0);
          const dayStart = anchor.getTime();
          const dayEnd = dayStart + HOURS_IN_DAY * HOUR_MS;

          const bins = Array.from({ length: HOURS_IN_DAY }, (_, index) => {
            const start = dayStart + index * HOUR_MS;
            return {
              index,
              start,
              end: start + HOUR_MS,
              duration: 0,
            };
          });

          const segments = Array.isArray(history) ? history : [];
          for (const segment of segments) {
            if (!segment) continue;
            const rawStart = Number.isFinite(segment.start) ? segment.start : effectiveNow;
            const rawEndCandidate = Number.isFinite(segment.end) ? segment.end : effectiveNow;
            const safeEnd = Math.max(rawEndCandidate, rawStart);
            const normalizedStart = Math.max(rawStart, dayStart);
            const normalizedEnd = Math.min(safeEnd, dayEnd);
            if (Number.isNaN(normalizedStart) || Number.isNaN(normalizedEnd) || normalizedEnd <= normalizedStart) {
              continue;
            }

            for (const bin of bins) {
              if (bin.start >= normalizedEnd) {
                break;
              }
              if (bin.end <= normalizedStart) {
                continue;
              }
              const overlapStart = Math.max(normalizedStart, bin.start);
              const overlapEnd = Math.min(normalizedEnd, bin.end);
              if (overlapEnd > overlapStart) {
                bin.duration += overlapEnd - overlapStart;
              }
            }
          }

          const binsWithMeta = bins.map((bin) => {
            const hourLabel = new Date(bin.start)
              .toLocaleTimeString('fr-FR', { hour: '2-digit' })
              .replace(/\s*[hH]$/, '');
            return {
              ...bin,
              label: `${hourLabel}h`,
              isCurrent: effectiveNow >= bin.start && effectiveNow < bin.end,
              isPast: effectiveNow >= bin.end,
            };
          });

          const totalDuration = binsWithMeta.reduce((acc, bin) => acc + bin.duration, 0);
          const maxDuration = binsWithMeta.reduce((acc, bin) => Math.max(acc, bin.duration), 0);
          const peakBin = binsWithMeta.reduce((best, bin) => {
            if (bin.duration <= 0) {
              return best;
            }
            if (!best || bin.duration > best.duration) {
              return bin;
            }
            return best;
          }, null);

          return {
            bins: binsWithMeta,
            totalDuration,
            maxDuration,
            peakBin,
          };
        }, [history, now]);

        useEffect(() => {
          if (typeof window === 'undefined') return;
          const container = scrollContainerRef.current;
          const current = currentBinRef.current;
          if (!container || !current) return;

          const containerRect = container.getBoundingClientRect();
          const currentRect = current.getBoundingClientRect();
          const currentCenter = currentRect.left - containerRect.left + container.scrollLeft + currentRect.width / 2;
          const targetScrollLeft = currentCenter - container.clientWidth / 2;
          const maxScroll = Math.max(0, container.scrollWidth - container.clientWidth);
          const clampedTarget = Math.max(0, Math.min(targetScrollLeft, maxScroll));

          if (Math.abs(container.scrollLeft - clampedTarget) <= 1) {
            return;
          }

          const prefersReducedMotion = window.matchMedia?.('(prefers-reduced-motion: reduce)')?.matches;
          if (prefersReducedMotion) {
            container.scrollLeft = clampedTarget;
          } else {
            container.scrollTo({ left: clampedTarget, behavior: 'smooth' });
          }
        }, [chart]);

        const totalLabel = chart.totalDuration > 0 ? formatDuration(chart.totalDuration) : '0s';
        const peakLabel = chart.peakBin ? `${formatDuration(chart.peakBin.duration)} vers ${chart.peakBin.label}` : null;
        const hasData = chart.maxDuration > 0;

        return html`
          <section class="relative overflow-hidden rounded-3xl border border-white/10 bg-slate-950/60 p-8 shadow-xl shadow-slate-950/50 backdrop-blur-xl">
            <div class="pointer-events-none absolute -left-24 top-[-6rem] h-56 w-56 rounded-full bg-indigo-500/20 blur-3xl"></div>
            <div class="pointer-events-none absolute -right-24 bottom-[-8rem] h-64 w-64 rounded-full bg-fuchsia-500/20 blur-[110px]"></div>
            <div class="relative flex flex-col gap-6">
              <div class="flex flex-col gap-4 lg:flex-row lg:items-end lg:justify-between">
                <div class="space-y-2">
                  <p class="text-xs uppercase tracking-[0.35em] text-indigo-200/80">Chronologie</p>
                  <h2 class="text-2xl font-semibold text-white">Activité vocale par heure</h2>
                  <p class="text-sm text-slate-300">
                    Observe la répartition des interventions tout au long de la journée actuelle. Le graphique se met à jour en temps réel.
                  </p>
                </div>
                <div class="flex flex-col gap-1 rounded-2xl border border-white/10 bg-black/40 px-4 py-3 text-xs text-slate-300">
                  <span>
                    <span class="font-semibold text-white">${totalLabel}</span>
                    de prise de parole aujourd'hui
                  </span>
                  ${peakLabel
                    ? html`<span>Pic : ${peakLabel}</span>`
                    : html`<span>Aucune activité détectée pour le moment</span>`}
                </div>
              </div>
              <div class="relative">
                <div class="pointer-events-none absolute inset-x-0 bottom-0 h-14 bg-gradient-to-t from-slate-950/80 to-transparent"></div>
                <div ref=${scrollContainerRef} class="overflow-x-auto">
                  <div class="flex min-w-[48rem] items-end gap-2 pb-6 sm:gap-3 md:gap-4">
                    ${chart.bins.map((bin) => {
                      const rawPercent = chart.maxDuration > 0 ? (bin.duration / chart.maxDuration) * 100 : 0;
                      const heightPercent = bin.duration > 0 ? Math.max(6, Math.round(rawPercent)) : 0;
                      const barStyle = `height: ${heightPercent}%`;
                      const barClass = [
                        'w-full rounded-t-2xl transition-all duration-700 ease-out',
                        bin.duration > 0
                          ? 'bg-gradient-to-t from-indigo-500/70 via-fuchsia-500/60 to-fuchsia-400/80 shadow-[0_0_18px_rgba(236,72,153,0.35)]'
                          : 'bg-white/10',
                        bin.isCurrent ? 'ring-2 ring-fuchsia-300/80 shadow-[0_0_24px_rgba(236,72,153,0.45)]' : '',
                        !bin.isPast && !bin.isCurrent ? 'opacity-40' : '',
                      ]
                        .filter(Boolean)
                        .join(' ');
                      const tooltip = bin.duration > 0 ? `≈ ${formatDuration(bin.duration)}` : 'Aucune activité';
                      return html`
                        <div
                          key=${bin.start}
                          ref=${bin.isCurrent ? setCurrentBinRef : null}
                          class="flex min-w-[2.5rem] flex-1 flex-col items-center gap-2 text-xs text-slate-300"
                        >
                          <div
                            class="flex h-48 w-full items-end rounded-2xl bg-white/5 p-1"
                            title=${tooltip}
                            aria-label=${`${bin.label} · ${tooltip}`}
                          >
                            <div class=${barClass} style=${barStyle}></div>
                          </div>
                          <span class=${`font-semibold ${bin.isCurrent ? 'text-white' : 'text-slate-200'}`}>${bin.label}</span>
                        </div>
                      `;
                    })}
                  </div>
                </div>
                ${hasData
                  ? null
                  : html`<p class="mt-4 text-center text-sm text-slate-400">
                      Les premières prises de parole de la journée apparaîtront ici dès qu'une voix sera détectée.
                    </p>`}
              </div>
            </div>
          </section>
        `;
      };

      const RealTimeTalkChart = ({ history, speakers, now, selectedWindowMinutes, onWindowChange, onViewProfile }) => {
        const windowMs = selectedWindowMinutes * 60 * 1000;

        const speakerIndex = useMemo(() => {
          const map = new Map();
          for (const speaker of speakers) {
            if (speaker?.id) {
              map.set(speaker.id, speaker);
            }
          }
          return map;
        }, [speakers]);

        const chartData = useMemo(() => {
          const cutoff = now - windowMs;
          const totals = new Map();
          const profiles = new Map();

          for (const segment of history) {
            if (!segment || !segment.id) continue;
            const start = Number.isFinite(segment.start) ? segment.start : now;
            const end = Number.isFinite(segment.end) ? segment.end : now;
            if (end <= cutoff) {
              continue;
            }
            const effectiveStart = Math.max(start, cutoff);
            const effectiveEnd = Math.min(end, now);
            if (effectiveEnd <= effectiveStart) {
              continue;
            }
            const duration = effectiveEnd - effectiveStart;
            totals.set(segment.id, (totals.get(segment.id) ?? 0) + duration);
            profiles.set(segment.id, mergeProfiles(profiles.get(segment.id), segment.profile));
          }

          const items = Array.from(totals.entries()).map(([id, duration]) => {
            const profile = profiles.get(id) ?? speakerIndex.get(id) ?? {};
            const display = (profile.displayName && profile.displayName.trim())
              ? profile.displayName.trim()
              : (profile.username && profile.username.trim())
              ? profile.username.trim()
              : `Intervenant ${String(id).slice(-4).padStart(4, '0')}`;
            return {
              id,
              label: display,
              avatar: profile.avatar ?? null,
              duration,
            };
          });

          items.sort((a, b) => b.duration - a.duration);

          const totalDuration = items.reduce((acc, item) => acc + item.duration, 0);
          const maxDuration = items.length ? Math.max(...items.map((item) => item.duration)) : 0;

          return {
            items,
            totalDuration,
            maxDuration,
          };
        }, [history, now, windowMs, speakerIndex]);

        const minutesLabel = selectedWindowMinutes > 1 ? `${selectedWindowMinutes} dernières minutes` : 'Dernière minute';
        const totalLabel = chartData.totalDuration > 0 ? formatDuration(chartData.totalDuration) : '0s';
        const activeCount = chartData.items.length;
        const topSpeaker = chartData.items[0];

        const percentageFor = (value) => {
          if (!chartData.totalDuration || !Number.isFinite(value) || chartData.totalDuration <= 0) {
            return '0%';
          }
          const ratio = Math.max(0, Math.min(1, value / chartData.totalDuration));
          return `${Math.round(ratio * 100)}%`;
        };

        return html`
          <section class="relative overflow-hidden rounded-3xl border border-white/10 bg-gradient-to-br from-slate-950/90 via-indigo-950/60 to-fuchsia-950/40 p-8 shadow-xl shadow-slate-950/50 backdrop-blur-xl">
            <div class="pointer-events-none absolute -left-20 top-[-8rem] h-64 w-64 rounded-full bg-indigo-500/20 blur-3xl"></div>
            <div class="pointer-events-none absolute -right-24 bottom-[-10rem] h-72 w-72 rounded-full bg-fuchsia-500/25 blur-[120px]"></div>
            <div class="relative flex flex-col gap-6">
              <div class="flex flex-col gap-4 lg:flex-row lg:items-end lg:justify-between">
                <div class="space-y-2">
                  <p class="text-xs uppercase tracking-[0.35em] text-indigo-200/80">Analyse temps réel</p>
                  <h2 class="text-2xl font-semibold text-white">Temps de parole cumulés</h2>
                  <p class="text-sm text-slate-300">Visualise la répartition des interventions vocales sur la période sélectionnée.</p>
                </div>
                <div class="flex flex-wrap items-center gap-4 rounded-2xl border border-white/10 bg-black/30 px-4 py-3 text-sm text-slate-200">
                  <label class="flex items-center gap-2">
                    <span class="text-xs uppercase tracking-[0.3em] text-indigo-200">Fenêtre</span>
                    <select
                      class="rounded-full border border-white/20 bg-slate-900/60 px-3 py-1 text-sm font-medium text-white shadow-inner shadow-slate-950/40 focus:border-fuchsia-400 focus:outline-none"
                      value=${String(selectedWindowMinutes)}
                      onChange=${(event) => {
                        const minutes = Number(event.currentTarget.value);
                        if (Number.isFinite(minutes) && minutes > 0) {
                          onWindowChange(minutes);
                        }
                      }}
                    >
                      ${TALK_WINDOW_OPTIONS.map((option) => html`<option key=${option} value=${String(option)}>${option} min</option>`)}
                    </select>
                  </label>
                  <div class="flex flex-col text-xs text-slate-300">
                    <span class="font-semibold text-white">${minutesLabel}</span>
                    <span>${activeCount} intervenant${activeCount > 1 ? 's' : ''}</span>
                  </div>
                  <div class="flex flex-col text-xs text-slate-300">
                    <span class="font-semibold text-white">Temps cumulé</span>
                    <span>${totalLabel}</span>
                  </div>
                  ${topSpeaker
                    ? html`<div class="flex flex-col text-xs text-slate-300">
                        <span class="font-semibold text-white">Top voix</span>
                        <button
                          type="button"
                          class="mt-1 inline-flex w-max items-center gap-1 rounded-full border border-white/20 bg-white/10 px-2.5 py-1 text-[0.65rem] font-semibold uppercase tracking-[0.3em] text-white transition hover:border-fuchsia-400/40 hover:bg-fuchsia-500/20 focus:outline-none focus-visible:ring-2 focus-visible:ring-fuchsia-400/60 focus-visible:ring-offset-2 focus-visible:ring-offset-slate-950"
                          onClick=${() => {
                            if (typeof onViewProfile === 'function') {
                              onViewProfile(topSpeaker.id);
                            }
                          }}
                        >
                          ${topSpeaker.label}
                        </button>
                      </div>`
                    : null}
                </div>
              </div>

              ${chartData.items.length
                ? html`
                    <div class="relative space-y-4">
                      ${chartData.items.map((item) => {
                        const rawWidth = chartData.maxDuration > 0 ? Math.round((item.duration / chartData.maxDuration) * 100) : 0;
                        const widthPercent = item.duration > 0 ? Math.max(4, rawWidth) : 0;
                        const durationLabel = formatDuration(item.duration);
                        return html`
                          <button
                            key=${item.id}
                            type="button"
                            class="group flex w-full flex-col gap-3 rounded-2xl border border-white/10 bg-white/5 p-4 text-left transition hover:border-fuchsia-400/40 hover:bg-fuchsia-500/10 focus:outline-none focus-visible:ring-2 focus-visible:ring-fuchsia-400/60 focus-visible:ring-offset-2 focus-visible:ring-offset-slate-950"
                            onClick=${() => {
                              if (typeof onViewProfile === 'function') {
                                onViewProfile(item.id);
                              }
                            }}
                          >
                            <div class="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
                              <div class="flex items-center gap-3">
                                ${item.avatar
                                  ? html`<img src=${item.avatar} alt="Avatar ${item.label}" class="h-10 w-10 rounded-full border border-white/20 object-cover" />`
                                  : html`<div class="flex h-10 w-10 items-center justify-center rounded-full border border-white/10 bg-black/40 text-sm font-semibold uppercase text-slate-200">
                                      ${item.label.slice(0, 2)}
                                    </div>`}
                                <div>
                                  <p class="text-sm font-semibold text-white">${item.label}</p>
                                  <p class="text-xs text-slate-300">${durationLabel} · ${percentageFor(item.duration)}</p>
                                </div>
                              </div>
                              <div class="text-sm font-semibold text-indigo-200">${percentageFor(item.duration)}</div>
                            </div>
                            <div class="h-2 w-full overflow-hidden rounded-full bg-white/10">
                              <div
                                class="h-full rounded-full bg-gradient-to-r from-indigo-400 via-fuchsia-400 to-rose-400 shadow-lg shadow-fuchsia-500/40 transition-all duration-500"
                                style=${{ width: `${widthPercent}%` }}
                              ></div>
                            </div>
                          </button>
                        `;
                      })}
                    </div>
                  `
                : html`
                    <div class="flex flex-col items-center justify-center gap-4 rounded-2xl border border-dashed border-white/20 bg-black/30 px-8 py-12 text-center text-sm text-slate-300">
                      <div class="flex h-14 w-14 items-center justify-center rounded-full bg-white/10 text-indigo-200">
                        <${Clock3} class="h-7 w-7" aria-hidden="true" />
                      </div>
                      <p class="max-w-sm text-base text-slate-200">
                        Aucun temps de parole enregistré sur la période. Reviens plus tard ou réduis la fenêtre d'analyse.
                      </p>
                    </div>
                  `}
            </div>
          </section>
        `;
      };

      const AnonymousBooth = ({ slot, now }) => {
        const [session, setSession] = useState(() => ({
          token: null,
          alias: null,
          expiresAt: null,
          stage: 'idle',
          error: null,
          info: null,
          micGranted: false,
          wsConnected: false,
          level: 0,
        }));

        const tokenRef = useRef(null);
        const mediaStreamRef = useRef(null);
        const processorRef = useRef(null);
        const audioContextRef = useRef(null);
        const wsRef = useRef(null);
        const levelLastUpdateRef = useRef(0);
        const mountedRef = useRef(true);

        const ensurePrimaryStreamPlayback = useCallback(async () => {
          const audio = document.querySelector('audio[data-role="primary-stream"]');
          if (!audio) {
            return;
          }

          try {
            audio.muted = false;
            if (audio.paused) {
              await audio.play();
            }
          } catch (error) {
            console.warn('Impossible de maintenir la lecture du flux principal', error);
          }
        }, []);

        const stopAudioProcessing = useCallback(async () => {
          if (processorRef.current) {
            try {
              processorRef.current.disconnect();
            } catch (error) {
              console.warn('Impossible de déconnecter le processeur audio', error);
            }
            processorRef.current.onaudioprocess = null;
            processorRef.current = null;
          }

          if (mediaStreamRef.current) {
            try {
              for (const track of mediaStreamRef.current.getTracks()) {
                track.stop();
              }
            } catch (error) {
              console.warn('Impossible de stopper la capture micro', error);
            }
            mediaStreamRef.current = null;
          }

          if (audioContextRef.current) {
            try {
              await audioContextRef.current.close();
            } catch (error) {
              console.warn("Impossible de fermer l'AudioContext", error);
            }
            audioContextRef.current = null;
          }

          if (mountedRef.current) {
            setSession((prev) => ({ ...prev, micGranted: false, level: 0 }));
          }
        }, []);

        const cleanup = useCallback(
          async ({ notifyServer = false, reason = null } = {}) => {
            const socket = wsRef.current;
            if (socket) {
              wsRef.current = null;
              try {
                socket.onopen = null;
                socket.onclose = null;
                socket.onmessage = null;
                socket.onerror = null;
                socket.close();
              } catch (error) {
                console.warn('Impossible de fermer la connexion WebSocket anonyme', error);
              }
            }

            await stopAudioProcessing();
            await ensurePrimaryStreamPlayback();

            const tokenValue = tokenRef.current;
            tokenRef.current = null;

            if (notifyServer && tokenValue) {
              try {
                await fetch('/anonymous-slot', {
                  method: 'DELETE',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ token: tokenValue }),
                });
              } catch (error) {
                console.warn('Impossible de libérer le micro anonyme', error);
              }
            }

            if (mountedRef.current) {
              setSession((prev) => ({
                ...prev,
                token: null,
                alias: null,
                expiresAt: null,
                stage: 'idle',
                wsConnected: false,
                micGranted: false,
                level: 0,
                info: reason ?? prev.info,
                error: null,
              }));
            }
          },
          [stopAudioProcessing, ensurePrimaryStreamPlayback],
        );

        useEffect(() => () => {
          mountedRef.current = false;
          cleanup({ notifyServer: Boolean(tokenRef.current), reason: 'Micro libéré.' });
        }, [cleanup]);

        useEffect(() => {
          tokenRef.current = session.token;
        }, [session.token]);

        useEffect(() => {
          if (!session.token) {
            return;
          }

          if (!slot?.occupied) {
            cleanup({ notifyServer: false, reason: 'Micro libéré automatiquement.' });
            return;
          }

          if (slot.alias && session.alias && slot.alias !== session.alias) {
            cleanup({ notifyServer: false, reason: "Le micro est désormais occupé par quelqu'un d'autre." });
          }
        }, [slot?.occupied, slot?.alias, session.token, session.alias, cleanup]);

        useEffect(() => {
          if (!session.token || !session.alias) {
            return;
          }
          if (!slot?.alias || slot.alias !== session.alias) {
            return;
          }
          if (slot.expiresAt && slot.expiresAt !== session.expiresAt) {
            setSession((prev) => ({ ...prev, expiresAt: slot.expiresAt }));
          }
        }, [slot?.expiresAt, slot?.alias, session.alias, session.token, session.expiresAt]);

        const prepareMicrophone = useCallback(async () => {
          if (!navigator?.mediaDevices?.getUserMedia) {
            throw new Error("Ton navigateur ne supporte pas l'enregistrement audio.");
          }

          let stream;
          try {
            stream = await navigator.mediaDevices.getUserMedia({
              audio: {
                channelCount: 1,
                sampleRate: 48000,
                noiseSuppression: true,
                echoCancellation: true,
                autoGainControl: true,
              },
            });
          } catch (error) {
            throw new Error('Accès au micro refusé. Autorise ton micro pour intervenir.');
          }

          mediaStreamRef.current = stream;

          const AudioContextClass = window.AudioContext || window.webkitAudioContext;
          if (!AudioContextClass) {
            throw new Error('AudioContext indisponible sur ce navigateur.');
          }

          const audioContext = new AudioContextClass({ sampleRate: 48000 });
          audioContextRef.current = audioContext;
          if (audioContext.state === 'suspended') {
            try {
              await audioContext.resume();
            } catch (error) {
              console.warn("Impossible de reprendre l'AudioContext", error);
            }
          }

          await ensurePrimaryStreamPlayback();

          const source = audioContext.createMediaStreamSource(stream);
          const processor = audioContext.createScriptProcessor(1024, 1, 1);
          const gain = audioContext.createGain();
          gain.gain.value = 0;
          processor.connect(gain);
          gain.connect(audioContext.destination);
          source.connect(processor);
          processorRef.current = processor;

          processor.onaudioprocess = (event) => {
            const input = event.inputBuffer?.getChannelData?.(0);
            const output = event.outputBuffer?.getChannelData?.(0);
            if (!input) {
              return;
            }

            if (output) {
              for (let i = 0; i < output.length; i++) {
                output[i] = 0;
              }
            }

            const frameLength = input.length;
            const buffer = new ArrayBuffer(frameLength * 4);
            const view = new DataView(buffer);
            let sumSquares = 0;
            for (let i = 0; i < frameLength; i++) {
              const sample = input[i];
              sumSquares += sample * sample;
              const clamped = Math.max(-1, Math.min(1, sample));
              const intSample = clamped < 0 ? clamped * 0x8000 : clamped * 0x7fff;
              view.setInt16(i * 4, intSample, true);
              view.setInt16(i * 4 + 2, intSample, true);
            }

            const socket = wsRef.current;
            if (socket && socket.readyState === WebSocket.OPEN) {
              try {
                socket.send(buffer);
              } catch (error) {
                console.warn("Impossible d'envoyer un chunk audio anonyme", error);
              }
            }

            const level = frameLength > 0 ? Math.sqrt(sumSquares / frameLength) : 0;
            const nowPerf = typeof performance !== 'undefined' && performance.now ? performance.now() : Date.now();
            if (nowPerf - levelLastUpdateRef.current > 120) {
              levelLastUpdateRef.current = nowPerf;
              if (mountedRef.current) {
                setSession((prev) => ({ ...prev, level }));
              }
            }
          };

          if (mountedRef.current) {
            setSession((prev) => ({ ...prev, micGranted: true }));
          }
        }, [ensurePrimaryStreamPlayback]);

        const connectWebSocket = useCallback(() => {
          const tokenValue = tokenRef.current;
          if (!tokenValue) {
            if (mountedRef.current) {
              setSession((prev) => ({ ...prev, stage: 'idle', error: 'Session anonyme introuvable.', info: null }));
            }
            return;
          }

          const protocol = window.location.protocol === 'https:' ? 'wss' : 'ws';
          const socket = new WebSocket(
            `${protocol}://${window.location.host}/anonymous-stream?token=${encodeURIComponent(tokenValue)}`,
          );
          socket.binaryType = 'arraybuffer';
          wsRef.current = socket;

          socket.onopen = () => {
            if (!mountedRef.current) {
              return;
            }
            ensurePrimaryStreamPlayback().catch((error) => {
              console.warn('Impossible de reprendre le flux principal après connexion WS', error);
            });
            setSession((prev) => ({
              ...prev,
              stage: 'streaming',
              wsConnected: true,
              info: 'Tu es en direct. Reste cool et anonyme.',
              error: null,
            }));
          };

          socket.onmessage = (event) => {
            if (typeof event.data !== 'string') {
              return;
            }
            try {
              const payload = JSON.parse(event.data);
              if (payload?.type === 'terminated') {
                cleanup({ notifyServer: false, reason: payload.message || 'Session terminée.' });
              }
            } catch (error) {
              console.warn('Message WebSocket anonyme invalide', error);
            }
          };

          socket.onerror = (event) => {
            console.warn('Erreur WebSocket anonyme', event);
            if (mountedRef.current) {
              setSession((prev) => ({ ...prev, error: 'Connexion instable avec le bot.', wsConnected: false }));
            }
          };

          socket.onclose = (event) => {
            if (wsRef.current === socket) {
              wsRef.current = null;
            }
            stopAudioProcessing();
            ensurePrimaryStreamPlayback().catch((error) => {
              console.warn('Impossible de reprendre le flux principal après fermeture du micro', error);
            });
            tokenRef.current = null;
            if (mountedRef.current) {
              setSession((prev) => ({
                ...prev,
                token: null,
                alias: null,
                expiresAt: null,
                stage: 'idle',
                wsConnected: false,
                micGranted: false,
                level: 0,
                info: event?.reason || 'Connexion au micro fermée.',
              }));
            }
          };
        }, [cleanup, stopAudioProcessing, ensurePrimaryStreamPlayback]);

        const handleClaim = async () => {
          if (session.stage !== 'idle') {
            return;
          }

          if (mountedRef.current) {
            setSession((prev) => ({
              ...prev,
              stage: 'claiming',
              error: null,
              info: 'Réservation du micro en cours…',
            }));
          }

          let payload = {};
          try {
            const response = await fetch('/anonymous-slot', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
            });
            payload = await response.json().catch(() => ({}));
            if (!response.ok) {
              throw new Error(payload?.message || 'Le micro est déjà pris. Réessaie dans un instant.');
            }
          } catch (error) {
            const message = error instanceof Error ? error.message : 'Impossible de réserver le micro anonyme.';
            if (mountedRef.current) {
              setSession((prev) => ({ ...prev, stage: 'idle', error: message, info: null }));
            }
            return;
          }

          tokenRef.current = payload?.token || null;
          if (!tokenRef.current) {
            if (mountedRef.current) {
              setSession((prev) => ({ ...prev, stage: 'idle', error: 'Réponse du serveur invalide.', info: null }));
            }
            return;
          }

          if (mountedRef.current) {
            setSession((prev) => ({
              ...prev,
              token: payload.token,
              alias: payload.alias || 'Anonyme',
              expiresAt: payload.expiresAt || null,
              stage: 'preparing',
              error: null,
              info: 'Activation du micro en cours…',
            }));
          }

          try {
            await prepareMicrophone();
          } catch (error) {
            const message = error instanceof Error ? error.message : "Impossible d'initialiser ton micro.";
            await cleanup({ notifyServer: true, reason: message });
            if (mountedRef.current) {
              setSession((prev) => ({ ...prev, error: message, stage: 'idle', info: null }));
            }
            return;
          }

          if (mountedRef.current) {
            setSession((prev) => ({ ...prev, stage: 'connecting', info: 'Connexion au bot…' }));
          }

          connectWebSocket();
        };

        const handleRelease = () => {
          cleanup({ notifyServer: true, reason: 'Micro libéré.' });
        };

        const isOwner = Boolean(session.token && session.alias && slot?.alias === session.alias);
        const slotTaken = Boolean(slot?.occupied && (!session.alias || slot.alias !== session.alias));
        const stage = session.stage;
        const isBusy = stage === 'claiming';
        const canCancel = stage === 'preparing' || stage === 'connecting';
        const expiresAt = isOwner ? session.expiresAt ?? slot?.expiresAt ?? null : slot?.expiresAt ?? null;
        const timeRemainingMs = expiresAt ? Math.max(0, expiresAt - now) : slot?.remainingMs ?? null;
        const timeRemainingLabel = timeRemainingMs ? formatDuration(timeRemainingMs) : null;
        const levelPercent = Math.min(100, Math.round(Math.min(1, session.level) * 100));

        return html`
          <section class="relative overflow-hidden rounded-3xl border border-white/10 bg-white/5 p-8 backdrop-blur-xl">
            <div class="pointer-events-none absolute -left-24 top-[-10rem] h-64 w-64 rounded-full bg-indigo-500/20 blur-3xl"></div>
            <div class="pointer-events-none absolute -right-24 bottom-[-8rem] h-72 w-72 rounded-full bg-fuchsia-500/20 blur-[120px]"></div>
            <div class="relative flex flex-col gap-6 lg:flex-row lg:items-start lg:justify-between">
              <div class="flex-1 space-y-4">
                <div class="flex flex-wrap items-center gap-3 text-[0.65rem] uppercase tracking-[0.35em] text-indigo-200">
                  <span class="inline-flex items-center gap-2 rounded-full border border-indigo-400/40 bg-indigo-500/20 px-3 py-1 text-indigo-100">
                    <${Mic} class="h-3.5 w-3.5" aria-hidden="true" />
                    Micro anonyme
                  </span>
                  <span class="inline-flex items-center gap-1 text-[0.6rem] text-slate-300">
                    <${ShieldCheck} class="h-3 w-3" aria-hidden="true" />
                    <span>Identité masquée</span>
                  </span>
                </div>
                <h2 class="text-2xl font-semibold text-white sm:text-3xl">Micro anonyme instantané</h2>
                <p class="text-sm text-slate-300">
                  Réserve le slot, parle via le bot et reste totalement anonyme. Un seul micro secret à la fois.
                </p>

                ${slotTaken
                  ? html`<div class="flex flex-col gap-2 rounded-2xl border border-white/10 bg-white/5 px-4 py-3 text-sm text-slate-200">
                      <div class="flex items-center gap-2 text-slate-100">
                        <${Activity} class="h-4 w-4 text-fuchsia-200" aria-hidden="true" />
                        <span>${slot.alias ?? 'Anonyme'} est en direct</span>
                      </div>
                      <div class="flex items-center gap-2 text-[0.75rem] text-slate-300">
                        <${Clock3} class="h-3.5 w-3.5" aria-hidden="true" />
                        <span>${timeRemainingLabel ? `Temps restant estimé : ${timeRemainingLabel}` : 'Temps restant : —'}</span>
                      </div>
                      ${slot.connectionPending
                        ? html`<p class="text-xs text-slate-300/80">
                            La connexion est en cours, le micro sera actif d’ici quelques secondes.
                          </p>`
                        : null}
                    </div>`
                  : null}

                ${session.info
                  ? html`<div class="rounded-2xl border border-indigo-400/30 bg-indigo-500/10 px-4 py-3 text-sm text-indigo-100">
                      ${session.info}
                    </div>`
                  : null}

                ${session.error
                  ? html`<div class="flex items-center gap-2 rounded-2xl border border-rose-500/40 bg-rose-500/10 px-4 py-3 text-sm text-rose-100">
                      <${AlertCircle} class="h-4 w-4" aria-hidden="true" />
                      <span>${session.error}</span>
                    </div>`
                  : null}
              </div>

              <div class="w-full max-w-md rounded-2xl border border-white/10 bg-black/45 p-5 shadow-xl shadow-slate-950/30 backdrop-blur">
                ${isOwner
                  ? html`<div class="flex items-center justify-between rounded-xl border border-emerald-400/40 bg-emerald-500/10 px-4 py-3 text-sm text-emerald-100">
                      <span class="flex items-center gap-2">
                        <${ShieldCheck} class="h-4 w-4" aria-hidden="true" />
                        <span>Alias secret</span>
                      </span>
                      <span class="font-semibold text-emerald-200">${session.alias}</span>
                    </div>`
                  : null}

                ${isOwner && timeRemainingLabel
                  ? html`<div class="mt-3 flex items-center justify-between rounded-xl border border-fuchsia-400/40 bg-fuchsia-500/10 px-4 py-2 text-xs uppercase tracking-[0.3em] text-fuchsia-100">
                      <span class="flex items-center gap-2">
                        <${Clock3} class="h-3.5 w-3.5" aria-hidden="true" />
                        Chrono
                      </span>
                      <span class="text-sm tracking-normal">${timeRemainingLabel}</span>
                    </div>`
                  : null}

                ${isOwner
                  ? html`<div class="mt-4 space-y-4">
                      <div>
                        <p class="text-xs font-semibold uppercase tracking-[0.35em] text-slate-300">Niveau du micro</p>
                        <div class="mt-2 mic-meter">
                          <div class="mic-meter-bar" style=${{ width: `${levelPercent}%` }}></div>
                        </div>
                      </div>
                      <button
                        type="button"
                        class="flex w-full items-center justify-center gap-2 rounded-full border border-rose-400/40 bg-rose-500/20 px-5 py-2.5 text-sm font-semibold text-rose-100 transition hover:bg-rose-500/30 hover:text-white focus:outline-none focus:ring-2 focus:ring-rose-300 focus:ring-offset-2 focus:ring-offset-slate-950"
                        onClick=${handleRelease}
                      >
                        Raccrocher
                      </button>
                    </div>`
                  : isBusy
                  ? html`<div class="flex flex-col gap-3">
                      <button
                        type="button"
                        class="flex w-full items-center justify-center gap-2 rounded-full border border-white/10 bg-white/10 px-5 py-2.5 text-sm font-semibold text-slate-200"
                        disabled
                      >
                        <span class="h-4 w-4 animate-spin rounded-full border-2 border-slate-200 border-t-transparent"></span>
                        Réservation en cours…
                      </button>
                    </div>`
                  : canCancel
                  ? html`<div class="flex flex-col gap-3">
                      <button
                        type="button"
                        class="flex w-full items-center justify-center gap-2 rounded-full border border-white/10 bg-white/10 px-5 py-2.5 text-sm font-semibold text-slate-200"
                        disabled
                      >
                        <span class="h-4 w-4 animate-spin rounded-full border-2 border-slate-200 border-t-transparent"></span>
                        Connexion au bot…
                      </button>
                      <button
                        type="button"
                        class="flex w-full items-center justify-center gap-2 rounded-full border border-white/10 bg-slate-900/70 px-5 py-2.5 text-sm font-semibold text-slate-200 transition hover:bg-slate-900 focus:outline-none focus:ring-2 focus:ring-slate-300 focus:ring-offset-2 focus:ring-offset-slate-950"
                        onClick=${() => cleanup({ notifyServer: true, reason: 'Connexion annulée.' })}
                      >
                        Annuler
                      </button>
                    </div>`
                  : html`<div class="flex flex-col gap-3">
                      <button
                        type="button"
                        class="flex w-full items-center justify-center gap-2 rounded-full border border-fuchsia-400/60 bg-fuchsia-500/20 px-5 py-2.5 text-sm font-semibold text-fuchsia-100 shadow-lg shadow-fuchsia-900/40 transition hover:bg-fuchsia-500/30 hover:text-white focus:outline-none focus:ring-2 focus:ring-fuchsia-300 focus:ring-offset-2 focus:ring-offset-slate-950 disabled:cursor-not-allowed disabled:opacity-40"
                        onClick=${handleClaim}
                        disabled=${slotTaken}
                      >
                        ${slotTaken ? 'Micro occupé' : 'Prendre la parole anonymement'}
                        ${!slotTaken ? html`<${Mic} class="h-4 w-4" aria-hidden="true" />` : null}
                      </button>
                      <p class="text-xs text-slate-400">
                        ${slotTaken
                          ? 'Attends la fin du passage actuel pour réserver à ton tour.'
                          : 'Ton intervention est routée via le bot : aucune trace, aucun pseudo.'}
                      </p>
                    </div>`}
              </div>
            </div>
          </section>
        `;
      };

      const PAYMENT_PROVIDERS = {
        stripe: {
          label: 'Stripe',
          helper: 'Cartes bancaires, Apple Pay et Google Pay.',
          accent:
            'border-indigo-400/50 bg-indigo-500/20 hover:bg-indigo-500/30 focus:ring-indigo-300',
          Icon: CreditCard,
        },
        paypal: {
          label: 'PayPal',
          helper: 'Compte PayPal ou carte via PayPal Checkout.',
          accent:
            'border-sky-400/50 bg-sky-500/20 hover:bg-sky-500/30 focus:ring-sky-300',
          Icon: Wallet,
        },
        coingate: {
          label: 'CoinGate',
          helper: 'Crypto, Lightning Network et virements SEPA.',
          accent:
            'border-emerald-400/50 bg-emerald-500/20 hover:bg-emerald-500/30 focus:ring-emerald-300',
          Icon: Coins,
        },
      };

      const FEEDBACK_STYLES = {
        success: 'border-emerald-400/40 bg-emerald-500/10 text-emerald-100',
        info: 'border-sky-400/40 bg-sky-500/10 text-sky-100',
        error: 'border-rose-400/40 bg-rose-500/10 text-rose-100',
      };

      const MODERATION_SERVICES = [
        {
          id: 'mute-15m',
          title: 'Mute 15 minutes',
          price: '1,50\u00A0€',
          description: 'Coupe immédiatement le micro sans exclure la personne du salon.',
          accent: 'border-emerald-400/40 bg-emerald-500/10',
          categoryLabel: 'Option mute',
        },
        {
          id: 'ban-60s',
          title: 'Bannissement 60 secondes',
          price: '1,10\u00A0€',
          description: 'Un rappel express pour calmer les débordements immédiats.',
          accent: 'border-emerald-400/40 bg-emerald-500/10',
          categoryLabel: 'Option bannissement',
        },
        {
          id: 'ban-5m',
          title: 'Bannissement 5 minutes',
          price: '2,20\u00A0€',
          description: 'Idéal pour faire retomber la pression et rétablir le calme.',
          accent: 'border-sky-400/40 bg-sky-500/10',
          categoryLabel: 'Option bannissement',
        },
        {
          id: 'ban-10m',
          title: 'Bannissement 10 minutes',
          price: '3,30\u00A0€',
          description: 'Parfait pour rappeler les règles sans exclure définitivement.',
          accent: 'border-indigo-400/40 bg-indigo-500/10',
          categoryLabel: 'Option bannissement',
        },
        {
          id: 'ban-1h',
          title: 'Bannissement 1 heure',
          price: '11,00\u00A0€',
          description: 'Temps suffisant pour protéger la discussion et consulter l’équipe.',
          accent: 'border-fuchsia-400/40 bg-fuchsia-500/10',
          categoryLabel: 'Option bannissement',
        },
        {
          id: 'ban-24h',
          title: 'Bannissement 24 heures',
          price: '22,00\u00A0€',
          description: 'Mesure ferme pour les récidivistes ou incidents graves.',
          accent: 'border-amber-400/40 bg-amber-500/10',
          categoryLabel: 'Option bannissement',
        },
        {
          id: 'ban-1w',
          title: 'Bannissement 1 semaine',
          price: '55,00\u00A0€',
          description: 'Sanction longue durée pour comportements incompatibles avec la vibe.',
          accent: 'border-rose-400/40 bg-rose-500/10',
          categoryLabel: 'Option bannissement',
        },
      ];

      const parseCheckoutFeedback = () => {
        if (typeof window === 'undefined') {
          return null;
        }

        try {
          const hash = window.location.hash || '';
          const [path = '', query = ''] = hash.split('?');
          if (!path.toLowerCase().includes('boutique')) {
            return null;
          }

          const params = new URLSearchParams(query);
          const status = (params.get('checkout') || '').toLowerCase();
          if (!status) {
            return null;
          }

          let type = 'info';
          let message = '';
          if (status === 'success') {
            type = 'success';
            message = 'Merci pour ton soutien ! La commande est bien prise en compte.';
          } else if (status === 'cancelled') {
            type = 'info';
            message = 'Paiement annulé. Tu peux réessayer quand tu veux.';
          } else {
            type = 'error';
            message = 'Une erreur est survenue lors du paiement. Aucun débit n’a été effectué.';
          }

          if (typeof window.history?.replaceState === 'function') {
            window.history.replaceState(null, '', '#/boutique');
          }

          return { type, message };
        } catch (error) {
          console.warn('Impossible de lire le statut de paiement', error);
          return null;
        }
      };

      const ShopProductCard = ({ product, checkoutState, onCheckout }) => {
        const providerSections = (product.providers || [])
          .map((provider) => {
            const details = PAYMENT_PROVIDERS[provider];
            if (!details) {
              return null;
            }
            const isPending =
              checkoutState.pending &&
              checkoutState.productId === product.id &&
              checkoutState.provider === provider;
            const ButtonIcon = details.Icon;
            return html`
              <div key=${`${product.id}-${provider}`} class="flex flex-col gap-1">
                <button
                  type="button"
                  class=${`flex w-full items-center justify-center gap-2 rounded-full border px-4 py-2 text-sm font-semibold text-white transition focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-slate-950 disabled:cursor-not-allowed disabled:opacity-50 ${details.accent}`}
                  onClick=${() => onCheckout(product.id, provider)}
                  disabled=${isPending}
                >
                  ${isPending ? 'Redirection…' : `Payer avec ${details.label}`}
                  <${ButtonIcon} class="h-4 w-4" aria-hidden="true" />
                </button>
                <span class="text-xs text-slate-400">${details.helper}</span>
              </div>
            `;
          })
          .filter(Boolean);

        return html`
          <article class="flex h-full flex-col rounded-3xl border border-white/10 bg-white/5 p-6 shadow-lg shadow-slate-950/40 backdrop-blur">
            <div class="flex items-center justify-between">
              <span class="text-4xl" aria-hidden="true">${product.emoji || '🛒'}</span>
              ${product.highlight
                ? html`<span class="inline-flex items-center gap-1 rounded-full border border-fuchsia-400/40 bg-fuchsia-500/10 px-3 py-1 text-xs font-semibold uppercase tracking-[0.25em] text-fuchsia-100">
                    <${Sparkles} class="h-3 w-3" aria-hidden="true" />
                    <span class="tracking-normal">Coup de cœur</span>
                  </span>`
                : null}
            </div>
            ${Array.isArray(product.badges) && product.badges.length > 0
              ? html`<div class="mt-4 flex flex-wrap gap-2">
                  ${product.badges.map((badge, index) =>
                    html`<span
                      key=${`${product.id}-badge-${index}`}
                      class="inline-flex items-center gap-1 rounded-full border border-white/10 bg-black/30 px-3 py-1 text-[0.65rem] font-semibold uppercase tracking-[0.35em] text-slate-200/90"
                    >
                      <${BadgeCheck} class="h-3 w-3 text-emerald-300" aria-hidden="true" />
                      <span class="tracking-normal">${badge}</span>
                    </span>`
                  )}
                </div>`
              : null}
            <h3 class="mt-5 text-xl font-semibold text-white">${product.name}</h3>
            <p class="mt-2 text-sm leading-relaxed text-slate-300">${product.description}</p>
            <div class=${`mt-4 rounded-3xl border border-white/10 px-5 py-4 ${product.accentSoft || 'bg-white/10'}`}>
              <p class="text-3xl font-bold text-white">${product.price?.formatted || '—'}</p>
              <p class="text-xs uppercase tracking-[0.35em] text-slate-300">TTC</p>
            </div>
            <ul class="mt-5 space-y-2 text-sm text-slate-200">
              ${(product.includes || []).map((item, index) =>
                html`<li key=${`${product.id}-feature-${index}`} class="flex items-start gap-2">
                  <${ShieldCheck} class="mt-0.5 h-4 w-4 text-indigo-300" aria-hidden="true" />
                  <span>${item}</span>
                </li>`
              )}
            </ul>
            <p class="mt-4 flex items-center gap-2 text-xs text-slate-400">
              <${Truck} class="h-4 w-4" aria-hidden="true" />
              ${product.shippingEstimate || 'Livraison estimée communiquée après commande'}
            </p>
            <div class="mt-6 flex flex-col gap-3">
              ${providerSections.length > 0
                ? providerSections
                : html`<div class="rounded-2xl border border-white/10 bg-black/40 px-4 py-3 text-center text-sm text-slate-300">
                    Paiements bientôt disponibles pour ce produit.
                  </div>`}
            </div>
            ${checkoutState.error && checkoutState.productId === product.id
              ? html`<p class="mt-4 rounded-xl border border-rose-400/30 bg-rose-500/10 px-4 py-3 text-xs text-rose-100">
                  ${checkoutState.error}
                </p>`
              : null}
          </article>
        `;
      };

      const ShopPage = () => {
        const [loading, setLoading] = useState(true);
        const [products, setProducts] = useState([]);
        const [error, setError] = useState('');
        const [checkoutState, setCheckoutState] = useState({
          productId: null,
          provider: null,
          pending: false,
          error: '',
        });
        const [feedback, setFeedback] = useState(parseCheckoutFeedback);

        const fetchProducts = useCallback(async () => {
          setLoading(true);
          try {
            const response = await fetch('/api/shop/products');
            if (!response.ok) {
              throw new Error('Réponse inattendue du serveur.');
            }
            const payload = await response.json();
            const list = Array.isArray(payload?.products) ? payload.products : [];
            setProducts(list);
            setError('');
          } catch (err) {
            console.warn('Impossible de charger la boutique', err);
            setError('Boutique momentanément indisponible. Réessaie dans quelques minutes.');
          } finally {
            setLoading(false);
          }
        }, []);

        useEffect(() => {
          fetchProducts();
        }, [fetchProducts]);

        useEffect(() => {
          if (!feedback) {
            return undefined;
          }
          const timer = setTimeout(() => setFeedback(null), 6000);
          return () => clearTimeout(timer);
        }, [feedback]);

        const getReturnUrls = useCallback(() => {
          if (typeof window === 'undefined') {
            return { success: '', cancel: '' };
          }
          const base = `${window.location.origin}${window.location.pathname}${window.location.search}`;
          return {
            success: `${base}#/boutique?checkout=success`,
            cancel: `${base}#/boutique?checkout=cancelled`,
          };
        }, []);

        const handleCheckout = useCallback(
          async (productId, provider) => {
            setCheckoutState({ productId, provider, pending: true, error: '' });
            setFeedback(null);

            try {
              const { success, cancel } = getReturnUrls();
              const response = await fetch('/api/shop/checkout', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  productId,
                  provider,
                  successUrl: success || undefined,
                  cancelUrl: cancel || undefined,
                }),
              });

              if (!response.ok) {
                let message = 'Impossible de lancer le paiement.';
                try {
                  const data = await response.json();
                  if (data?.message) {
                    message = data.message;
                  }
                } catch (parseError) {
                  console.warn('Impossible de lire la réponse de paiement', parseError);
                }
                throw new Error(message);
              }

              const payload = await response.json();
              if (payload?.url) {
                window.location.href = payload.url;
                return;
              }

              throw new Error('Lien de paiement introuvable.');
            } catch (err) {
              const message =
                err instanceof Error ? err.message : 'Impossible de lancer le paiement.';
              setCheckoutState({ productId, provider, pending: false, error: message });
              setFeedback({ type: 'error', message });
            }
          },
          [getReturnUrls],
        );

        const sortedProducts = useMemo(() => {
          return products
            .slice()
            .sort((a, b) => Number(Boolean(b.highlight)) - Number(Boolean(a.highlight)));
        }, [products]);

        return html`
          <${Fragment}>
            <section class="space-y-6 rounded-3xl border border-white/10 bg-white/5 px-8 py-12 shadow-xl shadow-slate-950/40 backdrop-blur-xl">
              <p class="text-xs uppercase tracking-[0.35em] text-slate-300">Boutique officielle</p>
              <div class="grid gap-8 lg:grid-cols-[1.1fr_1fr] lg:items-center">
                <div class="space-y-4">
                  <h1 class="text-4xl font-bold tracking-tight text-white sm:text-5xl">
                    La Boutique Libre Antenne
                  </h1>
                  <p class="text-base leading-relaxed text-slate-200">
                    Soutiens la libre antenne et repars avec des pièces conçues pour les noctambules,
                    les gamers et les voix libres. Paiement sécurisé via Stripe, PayPal ou CoinGate.
                  </p>
                  <div class="flex flex-wrap gap-3 text-xs text-slate-200">
                    <span class="inline-flex items-center gap-2 rounded-full border border-white/15 bg-white/10 px-4 py-1.5">
                      <${ShoppingBag} class="h-4 w-4" aria-hidden="true" />
                      Stripe, PayPal & CoinGate
                    </span>
                    <span class="inline-flex items-center gap-2 rounded-full border border-white/15 bg-white/10 px-4 py-1.5">
                      <${Truck} class="h-4 w-4" aria-hidden="true" />
                      Livraison France & Europe
                    </span>
                    <span class="inline-flex items-center gap-2 rounded-full border border-white/15 bg-white/10 px-4 py-1.5">
                      <${Coffee} class="h-4 w-4" aria-hidden="true" />
                      Production à la demande
                    </span>
                  </div>
                </div>
                <div class="rounded-3xl border border-fuchsia-400/40 bg-fuchsia-500/10 px-6 py-6 text-sm text-fuchsia-100 shadow-lg shadow-fuchsia-900/30">
                  <p class="text-xs uppercase tracking-[0.35em] text-fuchsia-200/80">Libre antenne</p>
                  <p class="mt-3 leading-relaxed">
                    Chaque achat finance l’hébergement du bot, le mixage audio et la préparation de
                    nouvelles émissions en roue libre. Merci de faire tourner la radio indépendante.
                  </p>
                </div>
              </div>
            </section>

            ${feedback
              ? (() => {
                  const style = FEEDBACK_STYLES[feedback.type] || FEEDBACK_STYLES.info;
                  const Icon =
                    feedback.type === 'success'
                      ? ShieldCheck
                      : feedback.type === 'error'
                      ? AlertCircle
                      : RefreshCcw;
                  return html`<div class=${`rounded-2xl border px-5 py-4 text-sm shadow-lg shadow-slate-950/40 backdrop-blur ${style}`}>
                    <div class="flex items-center gap-3">
                      <${Icon} class="h-4 w-4" aria-hidden="true" />
                      <span>${feedback.message}</span>
                    </div>
                  </div>`;
                })()
              : null}

            <section class="space-y-6">
              ${loading
                ? html`<div class="rounded-3xl border border-white/10 bg-black/30 px-6 py-10 text-center text-sm text-slate-300">
                    <span class="mr-3 inline-block h-4 w-4 animate-spin rounded-full border-2 border-slate-300 border-t-transparent"></span>
                    Chargement de la boutique…
                  </div>`
                : error
                ? html`<div class="rounded-3xl border border-rose-400/40 bg-rose-500/10 px-6 py-6 text-sm text-rose-100 shadow-lg shadow-rose-900/40">
                    <p>${error}</p>
                    <button
                      type="button"
                      class="mt-4 inline-flex items-center gap-2 rounded-full border border-white/30 bg-white/10 px-4 py-2 text-xs font-semibold uppercase tracking-[0.3em] text-white transition hover:bg-white/20"
                      onClick=${fetchProducts}
                    >
                      Réessayer
                      <${RefreshCcw} class="h-3.5 w-3.5" aria-hidden="true" />
                    </button>
                  </div>`
                : html`<div class="grid gap-6 md:grid-cols-2 xl:grid-cols-3">
                    ${sortedProducts.map((product) =>
                      html`<${ShopProductCard}
                        key=${product.id}
                        product=${product}
                        checkoutState=${checkoutState}
                        onCheckout=${handleCheckout}
                      />`
                    )}
                  </div>`}
            </section>

            <section class="grid gap-6 lg:grid-cols-2">
              <div class="rounded-3xl border border-white/10 bg-slate-950/60 p-6 shadow-lg shadow-slate-950/40 backdrop-blur">
                <h3 class="flex items-center gap-2 text-lg font-semibold text-white">
                  <${ShieldCheck} class="h-5 w-5 text-emerald-300" aria-hidden="true" />
                  Paiements vérifiés
                </h3>
                <p class="mt-3 text-sm leading-relaxed text-slate-300">
                  Stripe chiffre chaque transaction et accepte la plupart des cartes, Apple Pay et
                  Google Pay. Aucun numéro sensible n’est stocké sur nos serveurs.
                </p>
              </div>
              <div class="rounded-3xl border border-white/10 bg-slate-950/60 p-6 shadow-lg shadow-slate-950/40 backdrop-blur">
                <h3 class="flex items-center gap-2 text-lg font-semibold text-white">
                  <${Coins} class="h-5 w-5 text-emerald-300" aria-hidden="true" />
                  Crypto friendly
                </h3>
                <p class="mt-3 text-sm leading-relaxed text-slate-300">
                  CoinGate permet de régler en Bitcoin, Lightning Network et plus de 70 altcoins, avec
                  conversion instantanée en euros ou conservation en crypto.
                </p>
              </div>
            </section>
          </${Fragment}>
        `;
      };

      const MemberAvatar = ({ member }) => {
        const displayName = typeof member?.displayName === 'string' ? member.displayName : '';
        const username = typeof member?.username === 'string' ? member.username : '';
        const nickname = typeof member?.nickname === 'string' ? member.nickname : '';
        const sourceName = displayName || nickname || username;
        const initials = sourceName
          .split(/\s+/)
          .filter((part) => part.length > 0)
          .slice(0, 2)
          .map((part) => part[0]?.toUpperCase?.() ?? '')
          .join('') || 'LA';

        if (typeof member?.avatarUrl === 'string' && member.avatarUrl) {
          return html`<img
            src=${member.avatarUrl}
            alt=${sourceName || 'Avatar membre'}
            class="h-14 w-14 rounded-2xl border border-white/10 object-cover shadow-inner shadow-black/30"
            loading="lazy"
            decoding="async"
          />`;
        }

        return html`<div
          class="flex h-14 w-14 items-center justify-center rounded-2xl border border-white/10 bg-gradient-to-br from-indigo-500/40 via-purple-500/30 to-fuchsia-500/30 text-base font-semibold text-white shadow-inner shadow-black/30"
          aria-hidden="true"
        >
          ${initials}
        </div>`;
      };

      const MEMBERS_PAGE_SIZE = 24;

      const MembersPage = ({ onViewProfile }) => {
        const [members, setMembers] = useState([]);
        const [loading, setLoading] = useState(true);
        const [error, setError] = useState('');
        const [query, setQuery] = useState('');
        const [searchTerm, setSearchTerm] = useState('');
        const [cursorHistory, setCursorHistory] = useState([null]);
        const [pageIndex, setPageIndex] = useState(0);
        const [nextCursor, setNextCursor] = useState(null);
        const [refreshNonce, setRefreshNonce] = useState(0);

        useEffect(() => {
          const timer = setTimeout(() => {
            setSearchTerm(query.trim());
          }, 300);
          return () => clearTimeout(timer);
        }, [query]);

        useEffect(() => {
          setCursorHistory([null]);
          setPageIndex(0);
        }, [searchTerm]);

        const currentCursor = useMemo(() => {
          if (cursorHistory.length === 0) {
            return null;
          }
          const index = Math.min(Math.max(pageIndex, 0), cursorHistory.length - 1);
          return cursorHistory[index] ?? null;
        }, [cursorHistory, pageIndex]);

        useEffect(() => {
          let isActive = true;
          const controller = new AbortController();

          const loadMembers = async () => {
            setLoading(true);
            setError('');
            setNextCursor(null);

            try {
              const params = new URLSearchParams();
              params.set('limit', String(MEMBERS_PAGE_SIZE));
              if (currentCursor) {
                params.set('after', currentCursor);
              }
              if (searchTerm) {
                params.set('search', searchTerm);
              }

              const response = await fetch(`/api/members?${params.toString()}`, {
                signal: controller.signal,
              });

              if (!response.ok) {
                let message = 'Impossible de récupérer les membres pour le moment.';
                try {
                  const payload = await response.json();
                  if (payload?.message) {
                    message = String(payload.message);
                  }
                } catch (parseError) {
                  console.warn('Failed to parse member list error', parseError);
                }
                throw new Error(message);
              }

              const payload = await response.json();
              if (!isActive) {
                return;
              }

              const list = Array.isArray(payload?.members) ? payload.members : [];
              setMembers(list);

              const next =
                typeof payload?.nextCursor === 'string' && payload.nextCursor.trim().length > 0
                  ? payload.nextCursor.trim()
                  : null;
              setNextCursor(next);
            } catch (err) {
              if (controller.signal.aborted) {
                return;
              }
              console.warn('Impossible de récupérer les membres', err);
              if (!isActive) {
                return;
              }
              const message = err instanceof Error ? err.message : 'Impossible de récupérer les membres pour le moment.';
              setError(message);
              setMembers([]);
              setNextCursor(null);
            } finally {
              if (isActive) {
                setLoading(false);
              }
            }
          };

          loadMembers();

          return () => {
            isActive = false;
            controller.abort();
          };
        }, [currentCursor, searchTerm, refreshNonce]);

        const handleSearchSubmit = useCallback(
          (event) => {
            event.preventDefault();
            setSearchTerm(query.trim());
            setRefreshNonce((value) => value + 1);
          },
          [query],
        );

        const handleClearSearch = useCallback(() => {
          setQuery('');
          setSearchTerm('');
          setRefreshNonce((value) => value + 1);
        }, []);

        const handleNextPage = useCallback(() => {
          if (!nextCursor) {
            return;
          }
          setCursorHistory((prev) => {
            const base = prev.slice(0, pageIndex + 1);
            base.push(nextCursor);
            return base;
          });
          setPageIndex((value) => value + 1);
        }, [nextCursor, pageIndex]);

        const handlePreviousPage = useCallback(() => {
          setPageIndex((value) => Math.max(0, value - 1));
        }, []);

        const handleRefresh = useCallback(() => {
          setRefreshNonce((value) => value + 1);
        }, []);

        const handleOpenProfile = useCallback(
          (memberId) => {
            if (typeof onViewProfile === 'function' && memberId) {
              onViewProfile(memberId);
            }
          },
          [onViewProfile],
        );

        const appliedSearch = searchTerm.trim();
        const canGoPrevious = pageIndex > 0;
        const canGoNext = Boolean(nextCursor);
        const isInitialLoading = loading && members.length === 0 && !error;

        return html`
          <${Fragment}>
            <section class="space-y-6 rounded-3xl border border-white/10 bg-white/5 px-8 py-10 shadow-xl shadow-slate-950/40 backdrop-blur-xl">
              <div class="flex flex-col gap-6 md:flex-row md:items-start md:justify-between">
                <div class="space-y-4">
                  <p class="text-xs uppercase tracking-[0.35em] text-slate-300">Communauté</p>
                  <h1 class="text-4xl font-bold tracking-tight text-white sm:text-5xl">Les membres du serveur</h1>
                  <p class="text-sm leading-relaxed text-slate-300">
                    Explore la communauté de la Libre Antenne, découvre qui est présent et accède en un clic à leurs profils détaillés.
                  </p>
                </div>
                <div class="flex flex-col gap-3 text-xs text-slate-200 sm:flex-row sm:items-center">
                  <button
                    type="button"
                    class=${[
                      'inline-flex items-center gap-2 rounded-full border px-4 py-2 text-xs font-semibold uppercase tracking-[0.3em] transition',
                      loading ? 'border-white/10 bg-white/10 text-slate-300' : 'border-white/10 bg-white/5 text-slate-200 hover:bg-white/10 hover:text-white',
                    ].join(' ')}
                    onClick=${handleRefresh}
                    disabled=${loading}
                  >
                    <${RefreshCcw} class=${`h-3.5 w-3.5 ${loading ? 'animate-spin text-indigo-200' : ''}`} aria-hidden="true" />
                    Actualiser
                  </button>
                </div>
              </div>
            </section>

            <section class="space-y-6">
              <form class="relative" onSubmit=${handleSearchSubmit}>
                <label class="sr-only" for="member-search">Rechercher un membre</label>
                <div class="relative flex items-center">
                  <span class="pointer-events-none absolute left-4 text-slate-400">
                    <${Search} class="h-4 w-4" aria-hidden="true" />
                  </span>
                  <input
                    id="member-search"
                    type="search"
                    value=${query}
                    onInput=${(event) => setQuery(event.currentTarget.value)}
                    placeholder="Rechercher par pseudo ou nom d'utilisateur"
                    class="w-full rounded-3xl border border-white/10 bg-slate-950/60 py-3 pl-11 pr-12 text-sm text-white shadow-inner shadow-black/30 placeholder:text-slate-500 focus:border-fuchsia-300 focus:outline-none focus:ring-1 focus:ring-fuchsia-300"
                    autocomplete="off"
                  />
                  ${query
                    ? html`<button
                        type="button"
                        class="absolute right-3 inline-flex h-8 w-8 items-center justify-center rounded-full border border-white/10 bg-white/5 text-slate-300 transition hover:bg-white/10 hover:text-white"
                        onClick=${handleClearSearch}
                        aria-label="Effacer la recherche"
                      >
                        <${X} class="h-4 w-4" aria-hidden="true" />
                      </button>`
                    : null}
                </div>
              </form>

              ${appliedSearch
                ? html`<p class="text-xs text-slate-400">Résultats pour <span class="font-semibold text-white">“${appliedSearch}”</span>.</p>`
                : null}

              ${error
                ? html`<div class="rounded-3xl border border-rose-400/40 bg-rose-500/10 px-6 py-6 text-sm text-rose-100 shadow-lg shadow-rose-900/30">
                    <p>${error}</p>
                    <button
                      type="button"
                      class="mt-4 inline-flex items-center gap-2 rounded-full border border-white/20 bg-white/10 px-4 py-2 text-xs font-semibold uppercase tracking-[0.3em] text-white transition hover:bg-white/20"
                      onClick=${handleRefresh}
                    >
                      Réessayer
                      <${RefreshCcw} class="h-3.5 w-3.5" aria-hidden="true" />
                    </button>
                  </div>`
                : null}

              ${isInitialLoading
                ? html`<div class="grid gap-5 sm:grid-cols-2 xl:grid-cols-3">
                    ${Array.from({ length: 6 }).map((_, index) =>
                      html`<div key=${`skeleton-${index}`} class="h-36 animate-pulse rounded-3xl border border-white/5 bg-white/5"></div>`,
                    )}
                  </div>`
                : null}

              ${!error && members.length > 0
                ? html`<div class="grid gap-5 sm:grid-cols-2 xl:grid-cols-3">
                    ${members.map((member) => {
                      const id = typeof member?.id === 'string' ? member.id : '';
                      const displayName = (() => {
                        if (typeof member?.displayName === 'string' && member.displayName.trim().length > 0) {
                          return member.displayName.trim();
                        }
                        if (typeof member?.nickname === 'string' && member.nickname.trim().length > 0) {
                          return member.nickname.trim();
                        }
                        if (typeof member?.username === 'string' && member.username.trim().length > 0) {
                          return member.username.trim();
                        }
                        return 'Anonyme';
                      })();
                      const username = typeof member?.username === 'string' && member.username.trim().length > 0
                        ? member.username.trim()
                        : null;
                      const joinedMs = typeof member?.joinedAt === 'string' ? Date.parse(member.joinedAt) : NaN;
                      const roleList = Array.isArray(member?.roles)
                        ? member.roles
                            .filter((role) => role && typeof role.id === 'string' && typeof role.name === 'string')
                            .slice(0, 3)
                        : [];
                      const remainingRoles = Array.isArray(member?.roles) ? Math.max(member.roles.length - roleList.length, 0) : 0;
                      const isBot = Boolean(member?.isBot);

                      return html`<article
                        key=${id || displayName}
                        class="flex h-full cursor-pointer flex-col gap-4 rounded-3xl border border-white/10 bg-white/5 p-5 shadow-lg shadow-slate-950/40 backdrop-blur transition hover:border-white/20 hover:bg-white/10"
                        role="button"
                        tabIndex="0"
                        onClick=${() => handleOpenProfile(id)}
                        onKeyDown=${(event) => {
                          if (event.key === 'Enter' || event.key === ' ') {
                            event.preventDefault();
                            handleOpenProfile(id);
                          }
                        }}
                      >
                        <div class="flex items-center gap-4">
                          <${MemberAvatar} member=${member} />
                          <div class="min-w-0">
                            <h2 class="truncate text-lg font-semibold text-white">${displayName}</h2>
                            ${username
                              ? html`<p class="truncate text-sm text-slate-400">@${username}</p>`
                              : null}
                          </div>
                        </div>
                        <div class="space-y-3 text-xs text-slate-300">
                          <div class="flex items-center gap-2">
                            <${CalendarDays} class="h-3.5 w-3.5 text-slate-400" aria-hidden="true" />
                            <span>Arrivé(e) : ${Number.isFinite(joinedMs) ? formatDateTimeLabel(joinedMs, { includeSeconds: false }) : 'Date inconnue'}</span>
                          </div>
                          <div class="flex flex-wrap items-center gap-2">
                            ${roleList.length > 0
                              ? roleList.map((role) =>
                                  html`<span key=${`${id}-role-${role.id}`} class="inline-flex items-center gap-2 rounded-full border border-white/10 bg-white/5 px-3 py-1 text-[11px] font-semibold uppercase tracking-[0.25em] text-slate-200">
                                    ${role.name}
                                  </span>`,
                                )
                              : html`<span class="inline-flex items-center gap-2 rounded-full border border-white/10 bg-white/5 px-3 py-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">Sans rôle</span>`}
                            ${remainingRoles > 0
                              ? html`<span class="inline-flex items-center gap-2 rounded-full border border-white/10 bg-white/5 px-3 py-1 text-[11px] font-semibold uppercase tracking-[0.25em] text-slate-200">+${remainingRoles}</span>`
                              : null}
                            ${isBot
                              ? html`<span class="inline-flex items-center gap-1 rounded-full border border-emerald-400/40 bg-emerald-500/15 px-3 py-1 text-[11px] font-semibold uppercase tracking-[0.25em] text-emerald-200">
                                  Bot
                                  <${BadgeCheck} class="h-3 w-3" aria-hidden="true" />
                                </span>`
                              : null}
                          </div>
                        </div>
                        <div class="mt-auto"></div>
                      </article>`;
                    })}
                  </div>`
                : null}

              ${!error && !isInitialLoading && members.length === 0
                ? html`<div class="rounded-3xl border border-white/10 bg-white/5 px-6 py-10 text-center text-sm text-slate-300">
                    ${appliedSearch
                      ? html`Aucun membre ne correspond à « ${appliedSearch} » pour le moment.`
                      : 'Aucun membre à afficher pour l’instant.'}
                  </div>`
                : null}

              <div class="flex flex-col items-center justify-between gap-4 rounded-3xl border border-white/10 bg-white/5 px-4 py-4 text-sm text-slate-200 sm:flex-row">
                <div class="flex items-center gap-3">
                  <span class="inline-flex items-center gap-2 rounded-full border border-white/10 bg-white/5 px-3 py-1 text-xs uppercase tracking-[0.3em] text-slate-300">
                    Page
                  </span>
                  <span class="text-lg font-semibold text-white">${pageIndex + 1}</span>
                  ${loading
                    ? html`<span class="ml-2 inline-block h-3 w-3 animate-spin rounded-full border-2 border-slate-300 border-t-transparent"></span>`
                    : null}
                </div>
                <div class="flex items-center gap-3">
                  <button
                    type="button"
                    class=${[
                      'inline-flex items-center gap-2 rounded-full border px-4 py-2 text-xs font-semibold uppercase tracking-[0.3em] transition',
                      canGoPrevious && !loading
                        ? 'border-white/10 bg-white/5 text-slate-200 hover:bg-white/10 hover:text-white'
                        : 'border-white/5 bg-white/5 text-slate-500',
                    ].join(' ')}
                    onClick=${handlePreviousPage}
                    disabled=${!canGoPrevious || loading}
                  >
                    <${ArrowLeft} class="h-3.5 w-3.5" aria-hidden="true" />
                    Précédent
                  </button>
                  <button
                    type="button"
                    class=${[
                      'inline-flex items-center gap-2 rounded-full border px-4 py-2 text-xs font-semibold uppercase tracking-[0.3em] transition',
                      canGoNext && !loading
                        ? 'border-fuchsia-400/60 bg-fuchsia-500/20 text-fuchsia-100 hover:bg-fuchsia-500/30 hover:text-white'
                        : 'border-white/5 bg-white/5 text-slate-500',
                    ].join(' ')}
                    onClick=${handleNextPage}
                    disabled=${!canGoNext || loading}
                  >
                    Suivant
                    <${ArrowRight} class="h-3.5 w-3.5" aria-hidden="true" />
                  </button>
                </div>
              </div>
            </section>
          </${Fragment}>
        `;
      };

      const NAV_LINKS = [
        { label: 'Accueil', route: 'home', hash: '#/' },
        { label: 'Membres', route: 'members', hash: '#/membres' },
        { label: 'Boutique', route: 'shop', hash: '#/boutique' },
        {
          label: 'Classements',
          route: 'classements',
          hash: '#/classements',
          href: '/classements',
          external: true,
        },
        { label: 'Actions de modération', route: 'ban', hash: '#/bannir' },
        { label: 'À propos', route: 'about', hash: '#/about' },
      ];

      const getRouteFromHash = () => {
        const hash = window.location.hash.replace(/^#/, '');
        if (!hash || hash === '/') {
          return { name: 'home', params: {} };
        }

        const [pathPart, queryString] = hash.split('?');
        const segments = pathPart
          .split('/')
          .map((segment) => segment.trim())
          .filter((segment) => segment.length > 0);
        const search = new URLSearchParams(queryString || '');

        if (segments.length === 0) {
          return { name: 'home', params: {} };
        }

        const head = segments[0].toLowerCase();

        if (head === 'about') {
          return { name: 'about', params: {} };
        }
        if (head === 'membres' || head === 'members') {
          return { name: 'members', params: {} };
        }
        if (head === 'boutique') {
          return { name: 'shop', params: {} };
        }
        if (head === 'bannir' || head === 'ban') {
          return { name: 'ban', params: {} };
        }
        if (head === 'profil' || head === 'profile') {
          const userId = segments.length > 1 ? decodeURIComponent(segments[1]) : null;
          const since = search.get('since');
          const until = search.get('until');
          return {
            name: 'profile',
            params: { userId, since, until },
          };
        }
        if (head === 'home') {
          return { name: 'home', params: {} };
        }

        return { name: 'home', params: {} };
      };

      const AudioPlayer = ({ streamInfo, audioKey, status }) => {
        const audioRef = useRef(null);
        const [isPlaying, setIsPlaying] = useState(false);
        const [isLoading, setIsLoading] = useState(true);
        const [hasError, setHasError] = useState(false);
        const [isMuted, setIsMuted] = useState(false);
        const [volume, setVolume] = useState(0.75);
        const lastVolumeRef = useRef(0.75);

        const isIgnorablePlayError = (error) => {
          if (!error) return false;
          const name = error.name || '';
          return name === 'AbortError' || name === 'NotAllowedError';
        };

        useEffect(() => {
          const audio = audioRef.current;
          if (!audio) return undefined;

          const handlePlaying = () => {
            setIsPlaying(true);
            setIsLoading(false);
            setHasError(false);
          };

          const handleWaiting = () => {
            if (!audio.paused) {
              setIsLoading(true);
            }
          };

          const handlePause = () => {
            setIsPlaying(false);
            setIsLoading(false);
          };

          const handleCanPlay = () => {
            setIsLoading(false);
          };

          const handleError = () => {
            setHasError(true);
            setIsPlaying(false);
            setIsLoading(false);
          };

          const handleEnded = () => {
            setIsPlaying(false);
          };

          audio.addEventListener('playing', handlePlaying);
          audio.addEventListener('waiting', handleWaiting);
          audio.addEventListener('pause', handlePause);
          audio.addEventListener('canplay', handleCanPlay);
          audio.addEventListener('canplaythrough', handleCanPlay);
          audio.addEventListener('stalled', handleWaiting);
          audio.addEventListener('suspend', handleWaiting);
          audio.addEventListener('error', handleError);
          audio.addEventListener('ended', handleEnded);

          return () => {
            audio.removeEventListener('playing', handlePlaying);
            audio.removeEventListener('waiting', handleWaiting);
            audio.removeEventListener('pause', handlePause);
            audio.removeEventListener('canplay', handleCanPlay);
            audio.removeEventListener('canplaythrough', handleCanPlay);
            audio.removeEventListener('stalled', handleWaiting);
            audio.removeEventListener('suspend', handleWaiting);
            audio.removeEventListener('error', handleError);
            audio.removeEventListener('ended', handleEnded);
          };
        }, []);

        useEffect(() => {
          const audio = audioRef.current;
          if (!audio) return;
          audio.volume = Math.min(1, Math.max(0, volume));
        }, [volume]);

        useEffect(() => {
          const audio = audioRef.current;
          if (!audio) return;
          audio.muted = isMuted;
        }, [isMuted]);

        useEffect(() => {
          const audio = audioRef.current;
          if (!audio) return;

          setHasError(false);

          if (!audio.paused) {
            audio.pause();
          }
          audio.src = streamInfo.path;
          audio.load();
          setIsLoading(true);

          const attemptPlay = async () => {
            try {
              await audio.play();
            } catch (error) {
              console.warn('Lecture automatique bloquée', error);
              setIsLoading(false);
            }
          };

          attemptPlay();

          return () => {
            audio.pause();
          };
        }, [audioKey, streamInfo.path]);

        const clearBrowserCaches = async () => {
          if (typeof window === 'undefined') {
            return;
          }

          if ('caches' in window) {
            try {
              const cacheNames = await caches.keys();
              await Promise.all(
                cacheNames.map((cacheName) =>
                  caches.delete(cacheName).catch((error) => {
                    console.warn(`Impossible de supprimer le cache ${cacheName}`, error);
                    return false;
                  }),
                ),
              );
            } catch (error) {
              console.warn('Impossible de vider les caches du navigateur', error);
            }
          }

          if ('serviceWorker' in navigator) {
            try {
              const registrations = await navigator.serviceWorker.getRegistrations();
              await Promise.all(
                registrations.map((registration) =>
                  registration.unregister().catch((error) => {
                    console.warn('Impossible de désinscrire un service worker', error);
                    return false;
                  }),
                ),
              );
            } catch (error) {
              console.warn('Impossible de récupérer les service workers', error);
            }
          }
        };

        const togglePlay = async () => {
          const audio = audioRef.current;
          if (!audio) return;

          if (hasError) {
            setHasError(false);
          }

          if (isPlaying) {
            audio.pause();
            return;
          }

          setIsLoading(true);

          try {
            await clearBrowserCaches();
          } catch (error) {
            console.warn('Impossible de vider le cache du navigateur avant la lecture', error);
          }

          try {
            audio.currentTime = 0;
            audio.load();
          } catch (error) {
            console.warn('Impossible de recharger la source audio', error);
          }

          try {
            await audio.play();
          } catch (error) {
            if (isIgnorablePlayError(error)) {
              setIsLoading(false);
              return;
            }
            console.error('Impossible de lancer la lecture', error);
            setHasError(true);
            setIsLoading(false);
          }
        };

        const handleRetry = async () => {
          const audio = audioRef.current;
          if (!audio) return;

          setHasError(false);
          setIsLoading(true);

          try {
            await clearBrowserCaches();
          } catch (error) {
            console.warn('Impossible de vider le cache du navigateur avant la relance', error);
          }

          if (!audio.paused) {
            audio.pause();
          }
          audio.src = streamInfo.path;

          try {
            audio.currentTime = 0;
            audio.load();
          } catch (error) {
            console.warn('Impossible de recharger la source audio avant la relance', error);
          }

          try {
            await audio.play();
          } catch (error) {
            if (isIgnorablePlayError(error)) {
              setIsLoading(false);
              return;
            }
            console.error('La relance du flux a échoué', error);
            setHasError(true);
            setIsLoading(false);
          }
        };

        const handleVolumeChange = (event) => {
          const value = Number(event?.target?.value ?? 0) / 100;
          const nextVolume = Number.isFinite(value) ? Math.min(1, Math.max(0, value)) : 0;
          setVolume(nextVolume);
          if (nextVolume === 0) {
            setIsMuted(true);
          } else {
            lastVolumeRef.current = nextVolume;
            if (isMuted) {
              setIsMuted(false);
            }
          }
        };

        const toggleMute = () => {
          if (isMuted || volume === 0) {
            const restored = lastVolumeRef.current > 0 ? lastVolumeRef.current : 0.5;
            setVolume(restored);
            setIsMuted(false);
          } else {
            lastVolumeRef.current = volume > 0 ? volume : lastVolumeRef.current;
            setIsMuted(true);
          }
        };

        const renderVolumeIcon = () => {
          if (hasError) {
            return html`<${AlertCircle} class="h-5 w-5" aria-hidden="true" />`;
          }

          if (isMuted || volume === 0) {
            return html`<${VolumeX} class="h-5 w-5" aria-hidden="true" />`;
          }

          if (volume < 0.4) {
            return html`<${Volume} class="h-5 w-5" aria-hidden="true" />`;
          }

          if (volume < 0.75) {
            return html`<${Volume1} class="h-5 w-5" aria-hidden="true" />`;
          }

          return html`<${Volume2} class="h-5 w-5" aria-hidden="true" />`;
        };

        const statusConfig = STATUS_LABELS[status] ?? STATUS_LABELS.connecting;
        const statusText = hasError
          ? 'Flux indisponible. Relance le flux pour réessayer.'
          : isLoading
          ? 'Connexion au flux…'
          : isPlaying
          ? 'Lecture en cours'
          : 'En pause';

        return html`
          <div class="relative mt-6 overflow-hidden rounded-2xl border border-white/10 bg-slate-950/80 p-6 shadow-2xl shadow-slate-950/60 backdrop-blur">
            <div class="pointer-events-none absolute -left-32 top-[-8rem] h-72 w-72 rounded-full bg-fuchsia-500/25 blur-3xl"></div>
            <div class="pointer-events-none absolute -right-36 bottom-[-10rem] h-80 w-80 rounded-full bg-indigo-500/25 blur-[110px]"></div>
            <div class="relative flex flex-col gap-6 xl:flex-row xl:items-center xl:justify-between">
              <div class="flex flex-1 flex-col gap-4 sm:flex-row sm:items-center">
                <div class="flex items-center gap-5">
                  <button
                    type="button"
                    class="relative flex h-24 w-24 shrink-0 items-center justify-center overflow-hidden rounded-full bg-gradient-to-br from-fuchsia-500 via-indigo-500 to-sky-400 text-white shadow-lg shadow-fuchsia-900/40 transition focus:outline-none focus:ring-2 focus:ring-fuchsia-300 focus:ring-offset-2 focus:ring-offset-slate-950 hover:scale-105 disabled:cursor-not-allowed disabled:opacity-60"
                    aria-label=${isPlaying ? 'Mettre le flux en pause' : 'Lancer la lecture du flux'}
                    onClick=${togglePlay}
                    disabled=${isLoading && !isPlaying && !hasError}
                  >
                    ${
                      hasError
                        ? html`<${AlertCircle} class="h-7 w-7" aria-hidden="true" />`
                        : isLoading && !isPlaying
                        ? html`<span class="h-6 w-6 animate-spin rounded-full border-2 border-white/70 border-t-transparent"></span>`
                        : isPlaying
                        ? html`<${Pause} class="h-7 w-7" aria-hidden="true" />`
                        : html`<${Play} class="h-7 w-7" aria-hidden="true" />`
                    }
                  </button>
                  <div class="space-y-3">
                    <div class="flex flex-wrap items-center gap-3">
                      <span class="inline-flex items-center gap-1.5 rounded-full border border-emerald-400/30 bg-emerald-400/10 px-2 py-0.5 text-[0.6rem] font-semibold uppercase tracking-[0.25em] text-emerald-100">
                        <span class="relative flex h-1.5 w-1.5">
                          <span class="absolute inline-flex h-full w-full animate-ping rounded-full bg-emerald-100 opacity-75"></span>
                          <span class="relative inline-flex h-1.5 w-1.5 rounded-full bg-emerald-600"></span>
                        </span>
                        <${Activity} class="h-3 w-3" aria-hidden="true" />
                        <span class="sr-only">Flux audio actif</span>
                      </span>
                      ${(() => {
                        const statusLabel = statusConfig.label ?? statusConfig.srLabel;
                        if (!statusLabel) {
                          return null;
                        }
                        if (statusLabel.trim().toLowerCase() === 'en direct') {
                          return null;
                        }
                        return html`
                          <span class="rounded-full border border-white/10 bg-white/10 px-3 py-1 text-[0.7rem] font-medium uppercase tracking-[0.35em] text-slate-200">
                            ${statusConfig.Icon
                              ? html`<span class="flex items-center gap-1">
                                    <${statusConfig.Icon} class="h-3.5 w-3.5" aria-hidden="true" />
                                    <span>${statusLabel}</span>
                                  </span>`
                              : statusLabel}
                          </span>
                        `;
                      })()}
                      ${
                        isPlaying
                          ? html`<div class="audio-wave flex items-end gap-1 text-fuchsia-200">
                              <span class="h-4 bg-current"></span>
                              <span class="h-6 bg-current"></span>
                              <span class="h-5 bg-current"></span>
                              <span class="h-7 bg-current"></span>
                            </div>`
                          : null
                      }
                    </div>
                    <p class="text-sm text-slate-200">
                      Libre Antenne diffuse le salon vocal en continu. Branche-toi et profite du chaos.
                    </p>
                    <p class=${`text-xs font-medium ${hasError ? 'text-rose-200' : 'text-slate-300'}`}>${statusText}</p>
                  </div>
                </div>
              </div>
              <div class="relative w-full max-w-md rounded-2xl border border-white/10 bg-black/40 p-4 backdrop-blur">
                <div class="flex flex-wrap items-center justify-between gap-2 text-[0.65rem] uppercase tracking-[0.35em] text-slate-300">
                  <span class="rounded-full border border-fuchsia-400/30 bg-fuchsia-500/10 px-3 py-1 text-fuchsia-100">
                    ${streamInfo.format === 'mp3' ? 'MP3' : 'OPUS'}
                  </span>
                  <span class="truncate text-[0.6rem] text-slate-400">Endpoint : ${streamInfo.path}</span>
                </div>
                <div class="mt-4 flex items-center gap-3">
                  <button
                    type="button"
                    class="flex h-10 w-10 items-center justify-center rounded-full border border-white/10 bg-white/5 text-slate-200 transition hover:border-white/30 hover:bg-white/10 hover:text-white focus:outline-none focus:ring-2 focus:ring-fuchsia-300 focus:ring-offset-2 focus:ring-offset-slate-950"
                    aria-label=${isMuted || volume === 0 ? 'Activer le son' : 'Couper le son'}
                    onClick=${toggleMute}
                  >
                    ${renderVolumeIcon()}
                  </button>
                  <input
                    type="range"
                    min="0"
                    max="100"
                    step="1"
                    value=${Math.round(volume * 100)}
                    onInput=${handleVolumeChange}
                    class="h-1 flex-1 cursor-pointer appearance-none rounded-full bg-white/20 accent-fuchsia-400 focus:outline-none focus:ring-0"
                    aria-label="Volume"
                  />
                  <span class="w-12 text-right text-xs text-slate-300">${Math.round(volume * 100)}%</span>
                </div>
              </div>
            </div>
            ${
              hasError
                ? html`<div class="relative mt-5 flex flex-wrap items-center gap-3 rounded-2xl border border-rose-500/40 bg-rose-500/10 px-4 py-3 text-sm text-rose-100">
                    <div class="flex items-center gap-2 font-semibold">
                      <${AlertCircle} class="h-5 w-5" aria-hidden="true" />
                      Flux indisponible
                    </div>
                    <button
                      type="button"
                      class="inline-flex items-center gap-2 rounded-full border border-rose-200/40 bg-rose-200/10 px-3 py-1 text-[0.65rem] font-semibold uppercase tracking-[0.3em] text-rose-100 transition hover:bg-rose-200/20"
                      onClick=${handleRetry}
                    >
                      Relancer le flux
                      <${RefreshCcw} class="h-3.5 w-3.5" aria-hidden="true" />
                    </button>
                  </div>`
                : null
            }
            <audio ref=${audioRef} preload="auto" playsinline crossorigin="anonymous" aria-hidden="true" data-role="primary-stream"></audio>
          </div>
        `;
      };

      const HomePage = ({
        status,
        lastUpdateLabel,
        streamInfo,
        audioKey,
        speakers,
        now,
        anonymousSlot,
        speakingHistory,
        selectedWindowMinutes,
        onWindowChange,
        onViewProfile,
      }) => {
        const connectedCount = speakers.length;
        const activeSpeakersCount = speakers.reduce(
          (count, speaker) => count + (speaker?.isSpeaking ? 1 : 0),
          0,
        );

        return html`
          <${Fragment}>
          <section
            class="relative overflow-hidden rounded-3xl border border-white/10 bg-white/5 px-8 py-12 shadow-xl shadow-slate-950/50 backdrop-blur-xl"
          >
            <div class="pointer-events-none absolute -right-24 -top-24 h-64 w-64 rounded-full bg-fuchsia-500/25 blur-3xl"></div>
            <${StatusBadge}
              status=${status}
              className="absolute right-4 top-4 sm:right-6 sm:top-6"
            />
            <div class="relative flex flex-col gap-6 lg:flex-row lg:items-center lg:justify-between">
              <div class="space-y-4">
                <h1 class="text-4xl font-bold tracking-tight text-white sm:text-5xl">Libre Antenne</h1>
                <p class="max-w-xl text-base text-slate-200">
                  Le chaos en direct : un refuge sans filtre pour drogués, marginaux, alcooliques, gamers et esprits libres.
                </p>
                <a
                  class="inline-flex items-center gap-2 rounded-full border border-fuchsia-400/60 bg-fuchsia-500/20 px-5 py-2 text-sm font-semibold text-fuchsia-100 shadow-lg shadow-fuchsia-900/40 transition hover:bg-fuchsia-500/30 hover:text-white"
                  href="https://discord.gg/btjTZ5C"
                  target="_blank"
                  rel="noopener noreferrer"
                >
                  Rejoindre le Discord
                  <${ArrowRight} class="h-4 w-4" aria-hidden="true" />
                </a>
              </div>
              <div class="flex flex-col items-start gap-3 text-left lg:items-end lg:text-right">
                <p class="text-xs text-slate-300">Dernière mise à jour : ${lastUpdateLabel}</p>
              </div>
            </div>
          </section>

          <section class="relative overflow-hidden rounded-3xl border border-white/10 bg-white/5 p-8 backdrop-blur-xl">
            <div class="pointer-events-none absolute -right-20 bottom-0 h-56 w-56 rounded-full bg-indigo-400/30 blur-3xl"></div>
            <div class="relative flex flex-col gap-6 lg:flex-row lg:items-center lg:justify-between">
              <div class="space-y-2">
                <h2 class="text-2xl font-semibold text-white">Flux audio en direct</h2>
                <p class="text-sm text-slate-300">
                  Clique sur lecture si le flux ne démarre pas automatiquement. Volume conseillé : casque 💜
                </p>
              </div>
            </div>
          <${AudioPlayer} streamInfo=${streamInfo} audioKey=${audioKey} status=${status} />
        </section>

        <${DailyActivityChart} history=${speakingHistory} now=${now} />

          <${RealTimeTalkChart}
          history=${speakingHistory}
          speakers=${speakers}
          now=${now}
            selectedWindowMinutes=${selectedWindowMinutes}
            onWindowChange=${onWindowChange}
            onViewProfile=${onViewProfile}
          />

          <${AnonymousBooth} slot=${anonymousSlot} now=${now} />

          <section class="relative overflow-hidden rounded-3xl border border-white/10 bg-white/5 p-8 backdrop-blur-xl">
            <div class="flex flex-col gap-4 sm:flex-row sm:items-center sm:justify-between">
              <div>
                <h2 class="text-2xl font-semibold text-white">Intervenants en temps réel</h2>
                <p class="text-sm text-slate-300">
                  Toutes les personnes connectées au salon vocal apparaissent ici et l’animation se déclenche dès qu’une voix est détectée.
                </p>
              </div>
              <div class="flex items-center gap-3 rounded-full border border-white/10 bg-black/40 px-4 py-1.5 text-xs tracking-[0.3em] text-indigo-200">
                <span class="sr-only">Statistiques vocales</span>
                <span class="flex items-center gap-2">
                  <${Users} class="h-3.5 w-3.5" aria-hidden="true" />
                  <span aria-hidden="true" class="text-sm font-semibold tracking-normal">${connectedCount}</span>
                  <span aria-hidden="true" class="text-[0.6rem] font-semibold uppercase tracking-[0.35em] text-indigo-200/80">Co</span>
                  <span class="sr-only">personnes connectées</span>
                </span>
                <span aria-hidden="true" class="text-indigo-300">·</span>
                <span class="flex items-center gap-2">
                  <${Activity} class="h-3.5 w-3.5" aria-hidden="true" />
                  <span aria-hidden="true" class="text-sm font-semibold tracking-normal">${activeSpeakersCount}</span>
                  <span aria-hidden="true" class="text-[0.6rem] font-semibold uppercase tracking-[0.35em] text-indigo-200/80">Actifs</span>
                  <span class="sr-only">personnes actives</span>
                </span>
              </div>
            </div>
            <${SpeakersSection} speakers=${speakers} now=${now} onViewProfile=${onViewProfile} />
          </section>
          </${Fragment}>
        `;
      };

      const PROFILE_RANGE_PRESETS = [
        { label: '24h', description: 'Dernières 24 heures', durationMs: 24 * HOUR_MS },
        { label: '48h', description: 'Dernières 48 heures', durationMs: 48 * HOUR_MS },
        { label: '7 j', description: '7 derniers jours', durationMs: 7 * DAY_MS },
        { label: '30 j', description: '30 derniers jours', durationMs: 30 * DAY_MS },
      ];

      const toInputValue = (ms) => {
        if (!Number.isFinite(ms)) {
          return '';
        }
        try {
          const iso = new Date(ms).toISOString();
          return iso.slice(0, 16);
        } catch (error) {
          console.warn('Impossible de formater la valeur datetime', error);
          return '';
        }
      };

      const formatDateTimeLabel = (ms, { includeDate = true, includeSeconds = false } = {}) => {
        if (!Number.isFinite(ms)) {
          return '—';
        }
        try {
          const options = includeDate
            ? { dateStyle: 'medium', timeStyle: includeSeconds ? 'medium' : 'short' }
            : { timeStyle: includeSeconds ? 'medium' : 'short' };
          return new Date(ms).toLocaleString('fr-FR', options);
        } catch (error) {
          console.warn('Impossible de formater la date', error);
          return new Date(ms).toISOString();
        }
      };

      const formatRangeLabel = (sinceMs, untilMs) => {
        if (!Number.isFinite(sinceMs) || !Number.isFinite(untilMs)) {
          return 'Période inconnue';
        }
        const sinceDate = new Date(sinceMs);
        const untilDate = new Date(untilMs);
        const sameDay = sinceDate.toDateString() === untilDate.toDateString();
        if (sameDay) {
          const dateLabel = sinceDate.toLocaleDateString('fr-FR', {
            weekday: 'long',
            day: 'numeric',
            month: 'long',
          });
          const from = sinceDate.toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit' });
          const to = untilDate.toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit' });
          return `${dateLabel} · ${from} – ${to}`;
        }
        const from = sinceDate.toLocaleString('fr-FR', { dateStyle: 'medium', timeStyle: 'short' });
        const to = untilDate.toLocaleString('fr-FR', { dateStyle: 'medium', timeStyle: 'short' });
        return `Du ${from} au ${to}`;
      };

      const formatDayLabel = (ms) => {
        if (!Number.isFinite(ms)) {
          return 'Date inconnue';
        }
        const label = new Date(ms).toLocaleDateString('fr-FR', {
          weekday: 'long',
          day: 'numeric',
          month: 'long',
          year: 'numeric',
        });
        return label.charAt(0).toUpperCase() + label.slice(1);
      };

      const normalizeProfileRange = (params = {}, fallback = {}) => {
        const now = Date.now();
        const fallbackUntil = Number.isFinite(fallback.untilMs) ? fallback.untilMs : now;
        const untilCandidate = parseRangeValue(params.until);
        const sinceCandidate = parseRangeValue(params.since);
        const untilMs = Number.isFinite(untilCandidate) ? untilCandidate : fallbackUntil;
        let sinceMs = Number.isFinite(sinceCandidate) ? sinceCandidate : fallback.sinceMs;
        if (!Number.isFinite(sinceMs)) {
          sinceMs = untilMs - DEFAULT_PROFILE_RANGE_MS;
        }
        if (!Number.isFinite(sinceMs)) {
          sinceMs = now - DEFAULT_PROFILE_RANGE_MS;
        }
        if (sinceMs >= untilMs) {
          sinceMs = Math.max(0, untilMs - DEFAULT_PROFILE_RANGE_MS);
        }
        return {
          sinceMs: Math.max(0, sinceMs),
          untilMs: Math.max(untilMs, sinceMs + 1),
        };
      };

      const ProfileIdentityCard = ({ profile, userId }) => {
        const safeProfile = profile ?? {};
        const displayName =
          safeProfile.displayName
          ?? safeProfile.globalName
          ?? safeProfile.username
          ?? (userId ? `Utilisateur ${userId}` : 'Profil Discord');
        const discriminator = typeof safeProfile.discriminator === 'string' ? safeProfile.discriminator : null;
        const hasDiscriminator = discriminator && discriminator !== '0';
        const usernameTag = safeProfile.username
          ? hasDiscriminator
            ? `${safeProfile.username}#${discriminator}`
            : safeProfile.username
          : null;
        const guildNickname = safeProfile.guild?.displayName ?? safeProfile.guild?.nickname ?? null;
        const joinedGuildMs = safeProfile.guild?.joinedAt ? Date.parse(safeProfile.guild.joinedAt) : NaN;
        const createdMs = safeProfile.createdAt ? Date.parse(safeProfile.createdAt) : NaN;
        const roles = Array.isArray(safeProfile.guild?.roles) ? safeProfile.guild.roles : [];
        const initials = displayName
          .split(/\s+/)
          .map((part) => part.charAt(0))
          .filter(Boolean)
          .join('')
          .slice(0, 2)
          .toUpperCase();

        return html`
          <section class="relative overflow-hidden rounded-3xl border border-white/10 bg-white/5 p-6 shadow-xl shadow-slate-950/40 backdrop-blur-xl">
            <div class="pointer-events-none absolute -left-24 top-[-5rem] h-64 w-64 rounded-full bg-indigo-500/20 blur-3xl"></div>
            <div class="pointer-events-none absolute -right-24 bottom-[-6rem] h-64 w-64 rounded-full bg-fuchsia-500/20 blur-[110px]"></div>
            <div class="relative flex flex-col gap-6 sm:flex-row sm:items-center">
              <div class="flex-shrink-0">
                ${safeProfile.avatarUrl
                  ? html`<img
                      src=${safeProfile.avatarUrl}
                      alt=${`Avatar de ${displayName}`}
                      class="h-24 w-24 rounded-3xl border border-white/20 object-cover shadow-lg shadow-fuchsia-900/30"
                    />`
                  : html`<div
                      class="flex h-24 w-24 items-center justify-center rounded-3xl border border-dashed border-white/20 bg-black/40 text-2xl font-semibold uppercase text-fuchsia-200"
                    >
                      ${initials || '??'}
                    </div>`}
              </div>
              <div class="flex flex-1 flex-col gap-3">
                <div>
                  <p class="text-xs uppercase tracking-[0.35em] text-indigo-200/80">Profil Discord</p>
                  <h1 class="text-3xl font-bold text-white sm:text-4xl">${displayName}</h1>
                  ${usernameTag
                    ? html`<p class="text-sm text-slate-300">${usernameTag}</p>`
                    : null}
                </div>
                <div class="flex flex-wrap items-center gap-3 text-xs text-slate-200/90">
                  ${guildNickname && guildNickname !== displayName
                    ? html`<span class="inline-flex items-center gap-2 rounded-full border border-white/10 bg-white/10 px-3 py-1 backdrop-blur">
                        <${BadgeCheck} class="h-3.5 w-3.5 text-emerald-300" aria-hidden="true" />
                        <span>${guildNickname}</span>
                      </span>`
                    : null}
                  ${userId
                    ? html`<span class="inline-flex items-center gap-2 rounded-full border border-white/10 bg-white/10 px-3 py-1 backdrop-blur">
                        <${Users} class="h-3.5 w-3.5 text-indigo-200" aria-hidden="true" />
                        <span>ID : ${userId}</span>
                      </span>`
                    : null}
                </div>
                <div class="grid gap-3 rounded-2xl border border-white/10 bg-slate-950/40 p-4 text-sm text-slate-200 sm:grid-cols-2">
                  <div class="space-y-1">
                    <p class="text-xs uppercase tracking-[0.3em] text-slate-400">Compte Discord</p>
                    <p class="font-semibold text-white">${Number.isFinite(createdMs) ? formatDateTimeLabel(createdMs) : 'Date inconnue'}</p>
                  </div>
                  <div class="space-y-1">
                    <p class="text-xs uppercase tracking-[0.3em] text-slate-400">Arrivée sur le serveur</p>
                    <p class="font-semibold text-white">
                      ${Number.isFinite(joinedGuildMs) ? formatDateTimeLabel(joinedGuildMs) : '—'}
                    </p>
                  </div>
                </div>
                ${roles.length
                  ? html`<div class="flex flex-wrap gap-2">
                      ${roles.map(
                        (role) => html`<span
                          key=${role.id}
                          class="inline-flex items-center gap-2 rounded-full border border-white/10 bg-white/10 px-3 py-1 text-xs font-medium uppercase tracking-[0.2em] text-slate-100 backdrop-blur"
                        >
                          #${role.name}
                        </span>`,
                      )}
                    </div>`
                  : null}
              </div>
            </div>
          </section>
        `;
      };

      const ProfileSummaryCards = ({ stats }) => {
        if (!stats) {
          return null;
        }

        const safeDuration = (value) => {
          const label = formatDuration(value);
          return label && label.trim().length > 0 ? label : '0s';
        };

        const presenceSessions = stats.presenceSessions || 0;
        const speakingSessions = stats.speakingSessions || 0;
        const messageCount = Number.isFinite(stats.messageCount) ? stats.messageCount : 0;
        const activeDays = Number.isFinite(stats.activeDayCount) ? stats.activeDayCount : 0;

        const cards = [
          {
            key: 'presence',
            label: 'Temps en vocal',
            value: safeDuration(stats.totalPresenceMs),
            subLabel: `${presenceSessions} session${presenceSessions > 1 ? 's' : ''}`,
            Icon: Headphones,
          },
          {
            key: 'speaking',
            label: 'Temps de parole',
            value: safeDuration(stats.totalSpeakingMs),
            subLabel: `${speakingSessions} intervention${speakingSessions > 1 ? 's' : ''}`,
            Icon: Mic,
          },
          {
            key: 'messages',
            label: 'Messages envoyés',
            value: messageCount,
            subLabel: 'Sur la période analysée',
            Icon: MessageSquare,
          },
          {
            key: 'days',
            label: 'Jours actifs',
            value: activeDays,
            subLabel: `${stats.uniqueActiveDays?.length || 0} jours uniques`,
            Icon: CalendarDays,
          },
        ];

        return html`
          <section class="rounded-3xl border border-white/10 bg-slate-950/60 p-6 shadow-xl shadow-slate-950/40 backdrop-blur-xl">
            <div class="flex flex-col gap-6">
              <div>
                <p class="text-xs uppercase tracking-[0.35em] text-indigo-200/80">Synthèse</p>
                <h2 class="text-2xl font-semibold text-white">Résumé de l'activité</h2>
                <p class="text-sm text-slate-300">Une vue rapide de la présence de l'utilisateur sur la période sélectionnée.</p>
              </div>
              <div class="grid gap-4 sm:grid-cols-2">
                ${cards.map(
                  ({ key, label, value, subLabel, Icon }) => html`<div
                    key=${key}
                    class="flex items-start gap-4 rounded-2xl border border-white/10 bg-white/5 p-4 text-sm text-slate-200"
                  >
                    <div class="flex h-10 w-10 items-center justify-center rounded-2xl bg-gradient-to-br from-indigo-500/30 via-fuchsia-500/20 to-transparent text-fuchsia-200">
                      <${Icon} class="h-5 w-5" aria-hidden="true" />
                    </div>
                    <div class="space-y-1">
                      <p class="text-xs uppercase tracking-[0.3em] text-slate-400">${label}</p>
                      <p class="text-lg font-semibold text-white">${value}</p>
                      <p class="text-xs text-slate-300">${subLabel}</p>
                    </div>
                  </div>`,
                )}
              </div>
              <div class="grid gap-4 rounded-2xl border border-white/10 bg-black/40 p-4 text-xs text-slate-300 sm:grid-cols-2">
                <div class="space-y-1">
                  <p class="uppercase tracking-[0.3em] text-slate-400">Première activité</p>
                  <p class="text-sm font-semibold text-white">
                    ${stats.firstActivityAt?.ms ? formatDateTimeLabel(stats.firstActivityAt.ms) : '—'}
                  </p>
                </div>
                <div class="space-y-1">
                  <p class="uppercase tracking-[0.3em] text-slate-400">Dernière activité</p>
                  <p class="text-sm font-semibold text-white">
                    ${stats.lastActivityAt?.ms ? formatDateTimeLabel(stats.lastActivityAt.ms) : '—'}
                  </p>
                </div>
              </div>
            </div>
          </section>
        `;
      };

      const ProfileActivityTimeline = ({ range, presenceSegments = [], speakingSegments = [], messageEvents = [] }) => {
        const canvasRef = useRef(null);
        const chartRef = useRef(null);

        const chartData = useMemo(() => {
          const rangeStart = Number(range?.sinceMs);
          const rangeEnd = Number(range?.untilMs);
          if (!Number.isFinite(rangeStart) || !Number.isFinite(rangeEnd) || rangeEnd <= rangeStart) {
            return {
              hasValidRange: false,
              labels: [],
              presenceMinutes: [],
              speakingMinutes: [],
              messageCounts: [],
              buckets: [],
              totals: { presenceMs: 0, speakingMs: 0, messageCount: 0 },
            };
          }

          const duration = rangeEnd - rangeStart;
          let bucketCount = Math.round(duration / HOUR_MS);
          if (!Number.isFinite(bucketCount) || bucketCount <= 0) {
            bucketCount = 12;
          }
          bucketCount = Math.min(90, Math.max(12, bucketCount));
          const bucketSize = duration / bucketCount;

          const buckets = Array.from({ length: bucketCount }, (_, index) => {
            const start = rangeStart + bucketSize * index;
            const end = index === bucketCount - 1 ? rangeEnd : rangeStart + bucketSize * (index + 1);
            return {
              key: `${start}-${end}-${index}`,
              start,
              end,
              presenceMs: 0,
              speakingMs: 0,
              messageCount: 0,
            };
          });

          const accumulateSegments = (segments, boundsGetter, field) => {
            for (const segment of Array.isArray(segments) ? segments : []) {
              if (!segment) {
                continue;
              }
              const bounds = boundsGetter(segment);
              if (!bounds) {
                continue;
              }
              const [rawStart, rawEnd] = bounds;
              if (!Number.isFinite(rawStart) || !Number.isFinite(rawEnd) || rawEnd <= rawStart) {
                continue;
              }
              const clampedStart = Math.max(rangeStart, rawStart);
              const clampedEnd = Math.min(rangeEnd, rawEnd);
              if (clampedEnd <= clampedStart) {
                continue;
              }

              let bucketIndexStart = Math.floor((clampedStart - rangeStart) / bucketSize);
              let bucketIndexEnd = Math.floor((clampedEnd - rangeStart) / bucketSize);
              bucketIndexStart = Math.max(0, Math.min(bucketCount - 1, bucketIndexStart));
              bucketIndexEnd = Math.max(0, Math.min(bucketCount - 1, bucketIndexEnd));

              for (let index = bucketIndexStart; index <= bucketIndexEnd; index += 1) {
                const bucket = buckets[index];
                if (!bucket) {
                  continue;
                }
                const overlapStart = Math.max(bucket.start, clampedStart);
                const overlapEnd = Math.min(bucket.end, clampedEnd);
                const overlap = overlapEnd - overlapStart;
                if (overlap > 0) {
                  bucket[field] += overlap;
                }
              }
            }
          };

          accumulateSegments(
            presenceSegments,
            (segment) => {
              const start = Number(segment?.joinedAtMs);
              const endCandidate = Number(segment?.leftAtMs);
              const end = Number.isFinite(endCandidate) ? endCandidate : rangeEnd;
              if (!Number.isFinite(start)) {
                return null;
              }
              return [start, end];
            },
            'presenceMs',
          );

          accumulateSegments(
            speakingSegments,
            (segment) => {
              const start = Number(segment?.startedAtMs);
              const durationMs = Number(segment?.durationMs);
              if (!Number.isFinite(start)) {
                return null;
              }
              const end = Number.isFinite(durationMs) ? start + Math.max(durationMs, 0) : start;
              return [start, end];
            },
            'speakingMs',
          );

          for (const entry of Array.isArray(messageEvents) ? messageEvents : []) {
            if (!entry) {
              continue;
            }
            const timestamp = Number(entry?.timestampMs);
            if (!Number.isFinite(timestamp) || timestamp < rangeStart || timestamp > rangeEnd) {
              continue;
            }
            const relative = timestamp - rangeStart;
            let index = Math.floor(relative / bucketSize);
            if (!Number.isFinite(index)) {
              continue;
            }
            if (index >= buckets.length) {
              index = buckets.length - 1;
            }
            if (index < 0) {
              index = 0;
            }
            const bucket = buckets[index];
            if (bucket) {
              bucket.messageCount += 1;
            }
          }

          const formatBucketLabel = (start, end) => {
            const midpoint = start + (end - start) / 2;
            if (duration <= 6 * HOUR_MS) {
              return new Date(midpoint).toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit' });
            }
            if (duration <= 48 * HOUR_MS) {
              return new Date(midpoint).toLocaleString('fr-FR', {
                weekday: 'short',
                hour: '2-digit',
                minute: '2-digit',
              });
            }
            return new Date(midpoint).toLocaleDateString('fr-FR', { day: '2-digit', month: 'short' });
          };

          const labels = buckets.map((bucket) => formatBucketLabel(bucket.start, bucket.end));
          const presenceMinutes = buckets.map((bucket) => Number((bucket.presenceMs / MINUTE_MS).toFixed(2)));
          const speakingMinutes = buckets.map((bucket) => Number((bucket.speakingMs / MINUTE_MS).toFixed(2)));
          const messageCounts = buckets.map((bucket) => bucket.messageCount);

          const totals = {
            presenceMs: buckets.reduce((acc, bucket) => acc + bucket.presenceMs, 0),
            speakingMs: buckets.reduce((acc, bucket) => acc + bucket.speakingMs, 0),
            messageCount: buckets.reduce((acc, bucket) => acc + bucket.messageCount, 0),
          };

          return {
            hasValidRange: true,
            labels,
            presenceMinutes,
            speakingMinutes,
            messageCounts,
            buckets,
            totals,
          };
        }, [range?.sinceMs, range?.untilMs, presenceSegments, speakingSegments, messageEvents]);

        useEffect(() => {
          const canvas = canvasRef.current;
          if (!canvas) {
            if (chartRef.current) {
              chartRef.current.destroy();
              chartRef.current = null;
            }
            return undefined;
          }

          if (!chartData.hasValidRange || chartData.labels.length === 0) {
            if (chartRef.current) {
              chartRef.current.destroy();
              chartRef.current = null;
            }
            return undefined;
          }

          const context = canvas.getContext('2d');
          if (!context) {
            return undefined;
          }

          if (chartRef.current) {
            chartRef.current.destroy();
            chartRef.current = null;
          }

          const presenceGradient = context.createLinearGradient(0, 0, 0, canvas.height || 300);
          presenceGradient.addColorStop(0, 'rgba(16, 185, 129, 0.85)');
          presenceGradient.addColorStop(1, 'rgba(16, 185, 129, 0.45)');

          const speakingGradient = context.createLinearGradient(0, 0, 0, canvas.height || 300);
          speakingGradient.addColorStop(0, 'rgba(236, 72, 153, 0.85)');
          speakingGradient.addColorStop(1, 'rgba(236, 72, 153, 0.45)');

          const bucketMeta = chartData.buckets;

          const chart = new Chart(context, {
            type: 'bar',
            data: {
              labels: chartData.labels,
              datasets: [
                {
                  type: 'bar',
                  label: 'Présence vocale',
                  data: chartData.presenceMinutes,
                  backgroundColor: presenceGradient,
                  borderRadius: 6,
                  borderSkipped: false,
                  stack: 'activity',
                  barPercentage: 1,
                  categoryPercentage: 0.9,
                },
                {
                  type: 'bar',
                  label: 'Parole',
                  data: chartData.speakingMinutes,
                  backgroundColor: speakingGradient,
                  borderRadius: 6,
                  borderSkipped: false,
                  stack: 'activity',
                  barPercentage: 1,
                  categoryPercentage: 0.9,
                },
                {
                  type: 'line',
                  label: 'Messages',
                  data: chartData.messageCounts,
                  yAxisID: 'y1',
                  borderColor: 'rgba(129, 140, 248, 0.85)',
                  backgroundColor: 'rgba(129, 140, 248, 0.4)',
                  borderWidth: 2,
                  tension: 0.35,
                  pointRadius: 4,
                  pointHoverRadius: 6,
                  fill: false,
                },
              ],
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              interaction: {
                mode: 'index',
                intersect: false,
              },
              plugins: {
                legend: {
                  display: false,
                },
                tooltip: {
                  backgroundColor: 'rgba(15, 23, 42, 0.92)',
                  titleColor: '#e2e8f0',
                  bodyColor: '#cbd5f5',
                  borderColor: 'rgba(148, 163, 184, 0.25)',
                  borderWidth: 1,
                  padding: 12,
                  callbacks: {
                    title(items) {
                      const first = items?.[0];
                      if (!first) {
                        return '';
                      }
                      const bucket = bucketMeta[first.dataIndex];
                      if (!bucket) {
                        return first.label ?? '';
                      }
                      return `${formatDateTimeLabel(bucket.start)} → ${formatDateTimeLabel(bucket.end)}`;
                    },
                    label(context) {
                      const index = context.dataIndex;
                      const bucket = bucketMeta[index];
                      if (!bucket) {
                        return context.formattedValue;
                      }
                      if (context.dataset.type === 'line') {
                        const count = bucket.messageCount;
                        return `Messages : ${count}`;
                      }
                      if (context.dataset.label === 'Présence vocale') {
                        return `Présence : ${formatDuration(bucket.presenceMs)}`;
                      }
                      if (context.dataset.label === 'Parole') {
                        return `Parole : ${formatDuration(bucket.speakingMs)}`;
                      }
                      return context.formattedValue;
                    },
                  },
                },
              },
              scales: {
                x: {
                  ticks: {
                    maxRotation: 0,
                    color: 'rgba(203, 213, 225, 0.9)',
                  },
                  grid: {
                    color: 'rgba(30, 41, 59, 0.55)',
                  },
                },
                y: {
                  stacked: true,
                  beginAtZero: true,
                  title: {
                    display: true,
                    text: 'Minutes de présence/parole',
                    color: 'rgba(203, 213, 225, 0.9)',
                  },
                  ticks: {
                    color: 'rgba(203, 213, 225, 0.9)',
                    callback(value) {
                      if (!Number.isFinite(value)) {
                        return value;
                      }
                      return `${value} min`;
                    },
                  },
                  grid: {
                    color: 'rgba(30, 41, 59, 0.5)',
                  },
                },
                y1: {
                  position: 'right',
                  beginAtZero: true,
                  title: {
                    display: true,
                    text: 'Messages',
                    color: 'rgba(203, 213, 225, 0.9)',
                  },
                  ticks: {
                    color: 'rgba(203, 213, 225, 0.9)',
                    precision: 0,
                  },
                  grid: {
                    drawOnChartArea: false,
                  },
                },
              },
            },
          });

          chartRef.current = chart;

          return () => {
            chart.destroy();
            chartRef.current = null;
          };
        }, [chartData]);

        const hasAnyActivity =
          chartData.totals.presenceMs > 0
          || chartData.totals.speakingMs > 0
          || chartData.totals.messageCount > 0;
        const rangeLabel = formatRangeLabel(range?.sinceMs, range?.untilMs);

        return html`
          <section class="rounded-3xl border border-white/10 bg-white/5 p-6 shadow-xl shadow-slate-950/40 backdrop-blur-xl">
            <div class="flex flex-col gap-6">
              <div class="flex flex-col gap-2 md:flex-row md:items-end md:justify-between">
                <div>
                  <p class="text-xs uppercase tracking-[0.35em] text-indigo-200/80">Chronologie unifiée</p>
                  <h2 class="text-2xl font-semibold text-white">Activité détaillée</h2>
                  <p class="text-sm text-slate-300">${rangeLabel}</p>
                </div>
                <div class="flex flex-wrap gap-3 text-xs text-slate-300">
                  <span class="flex items-center gap-2 rounded-full border border-white/10 bg-emerald-500/20 px-3 py-1 text-emerald-100">
                    <span class="h-2 w-6 rounded-full bg-emerald-300"></span>
                    Présence vocale
                  </span>
                  <span class="flex items-center gap-2 rounded-full border border-white/10 bg-fuchsia-500/20 px-3 py-1 text-fuchsia-100">
                    <span class="h-2 w-6 rounded-full bg-fuchsia-300"></span>
                    Parole
                  </span>
                  <span class="flex items-center gap-2 rounded-full border border-white/10 bg-indigo-500/20 px-3 py-1 text-indigo-100">
                    <${MessageSquare} class="h-3.5 w-3.5" aria-hidden="true" />
                    Messages
                  </span>
                </div>
              </div>
              <div class="relative overflow-hidden rounded-3xl border border-white/10 bg-slate-950/80 p-6">
                ${hasAnyActivity && chartData.hasValidRange
                  ? html`
                      <div class="h-64 w-full">
                        <canvas
                          ref=${canvasRef}
                          class="h-full w-full"
                          role="img"
                          aria-label=${`Graphique Chart.js de l'activité détaillée ${rangeLabel ? `pour ${rangeLabel}` : ''}`}
                        ></canvas>
                      </div>
                    `
                  : html`
                      <div class="flex h-32 flex-col items-center justify-center gap-3 text-center text-sm text-slate-300">
                        <div class="flex h-12 w-12 items-center justify-center rounded-full border border-white/10 bg-white/10 text-indigo-200">
                          <${Clock3} class="h-5 w-5" aria-hidden="true" />
                        </div>
                        <p>Aucune activité détectée sur cette période.</p>
                      </div>
                    `}
              </div>
            </div>
          </section>
        `;
      };

      const DailyBreakdown = ({ range, presenceSegments = [], speakingSegments = [], messageEvents = [] }) => {
        const rows = useMemo(() => {
          const rangeStart = Number(range?.sinceMs);
          const rangeEnd = Number(range?.untilMs);
          if (!Number.isFinite(rangeStart) || !Number.isFinite(rangeEnd) || rangeEnd <= rangeStart) {
            return [];
          }

          const dayMap = new Map();

          const clamp = (start, end) => {
            const safeStart = Math.max(rangeStart, start);
            const safeEnd = Math.min(rangeEnd, end);
            if (!Number.isFinite(safeStart) || !Number.isFinite(safeEnd) || safeEnd <= safeStart) {
              return null;
            }
            return [safeStart, safeEnd];
          };

          const pushPart = (dayStartMs, durationMs, field) => {
            if (!Number.isFinite(dayStartMs) || !Number.isFinite(durationMs) || durationMs <= 0) {
              return;
            }
            const key = new Date(dayStartMs).toISOString().slice(0, 10);
            if (!dayMap.has(key)) {
              dayMap.set(key, {
                key,
                dayStartMs,
                presenceMs: 0,
                speakingMs: 0,
                messageCount: 0,
              });
            }
            const record = dayMap.get(key);
            record[field] += durationMs;
          };

          const splitSegment = (start, end, field) => {
            const clamped = clamp(start, end);
            if (!clamped) {
              return;
            }
            let [cursor, segmentEnd] = clamped;
            while (cursor < segmentEnd) {
              const dayStart = new Date(cursor);
              dayStart.setHours(0, 0, 0, 0);
              const dayStartMs = dayStart.getTime();
              const dayEndMs = dayStartMs + DAY_MS;
              const chunkEnd = Math.min(segmentEnd, dayEndMs);
              pushPart(dayStartMs, chunkEnd - cursor, field);
              cursor = chunkEnd;
            }
          };

          for (const segment of Array.isArray(presenceSegments) ? presenceSegments : []) {
            const start = Number(segment?.joinedAtMs);
            const endCandidate = Number(segment?.leftAtMs);
            const end = Number.isFinite(endCandidate) ? endCandidate : rangeEnd;
            if (!Number.isFinite(start)) {
              continue;
            }
            splitSegment(start, end, 'presenceMs');
          }

          for (const segment of Array.isArray(speakingSegments) ? speakingSegments : []) {
            const start = Number(segment?.startedAtMs);
            const durationMs = Number(segment?.durationMs);
            if (!Number.isFinite(start)) {
              continue;
            }
            const end = Number.isFinite(durationMs) ? start + Math.max(durationMs, 0) : start;
            splitSegment(start, end, 'speakingMs');
          }

          for (const entry of Array.isArray(messageEvents) ? messageEvents : []) {
            const timestamp = Number(entry?.timestampMs);
            if (!Number.isFinite(timestamp) || timestamp < rangeStart || timestamp > rangeEnd) {
              continue;
            }
            const dayStart = new Date(timestamp);
            dayStart.setHours(0, 0, 0, 0);
            const key = dayStart.toISOString().slice(0, 10);
            if (!dayMap.has(key)) {
              dayMap.set(key, {
                key,
                dayStartMs: dayStart.getTime(),
                presenceMs: 0,
                speakingMs: 0,
                messageCount: 0,
              });
            }
            dayMap.get(key).messageCount += 1;
          }

          return Array.from(dayMap.values()).sort((a, b) => b.dayStartMs - a.dayStartMs);
        }, [range?.sinceMs, range?.untilMs, presenceSegments, speakingSegments, messageEvents]);

        if (!rows.length) {
          return html`
            <section class="rounded-3xl border border-white/10 bg-white/5 p-6 text-center shadow-xl shadow-slate-950/40 backdrop-blur-xl text-sm text-slate-300">
              <div class="mx-auto flex h-12 w-12 items-center justify-center rounded-full border border-white/10 bg-white/10 text-indigo-200">
                <${Clock3} class="h-5 w-5" aria-hidden="true" />
              </div>
              <p class="mt-3 text-base text-slate-200">Aucune donnée quotidienne disponible sur cette période.</p>
            </section>
          `;
        }

        return html`
          <section class="rounded-3xl border border-white/10 bg-white/5 p-6 shadow-xl shadow-slate-950/40 backdrop-blur-xl">
            <div class="flex flex-col gap-6">
              <div>
                <p class="text-xs uppercase tracking-[0.35em] text-indigo-200/80">Détails jour par jour</p>
                <h2 class="text-2xl font-semibold text-white">Répartition quotidienne</h2>
                <p class="text-sm text-slate-300">Identifie rapidement les pics d'activité et les journées silencieuses.</p>
              </div>
              <div class="space-y-4">
                ${rows.map(
                  (row) => {
                    const presenceLabel = formatDuration(row.presenceMs) || '0s';
                    const speakingLabel = formatDuration(row.speakingMs) || '0s';
                    return html`<article
                      key=${row.key}
                      class="flex flex-col gap-3 rounded-2xl border border-white/10 bg-slate-950/70 p-4 text-sm text-slate-200 sm:flex-row sm:items-center sm:justify-between"
                    >
                      <div>
                        <p class="text-base font-semibold text-white">${formatDayLabel(row.dayStartMs)}</p>
                        <p class="text-xs text-slate-300">
                          Présence : ${presenceLabel} · Parole : ${speakingLabel}
                        </p>
                      </div>
                      <div class="flex flex-wrap items-center gap-3 text-xs">
                        <span class="inline-flex items-center gap-2 rounded-full border border-white/10 bg-emerald-500/20 px-3 py-1 text-emerald-100">
                          <span class="h-2 w-2 rounded-full bg-emerald-300"></span>
                          ${presenceLabel}
                        </span>
                        <span class="inline-flex items-center gap-2 rounded-full border border-white/10 bg-fuchsia-500/20 px-3 py-1 text-fuchsia-100">
                          <span class="h-2 w-2 rounded-full bg-fuchsia-300"></span>
                          ${speakingLabel}
                        </span>
                        <span class="inline-flex items-center gap-2 rounded-full border border-white/10 bg-indigo-500/20 px-3 py-1 text-indigo-100">
                          <${MessageSquare} class="h-3.5 w-3.5" aria-hidden="true" />
                          ${row.messageCount} message${row.messageCount > 1 ? 's' : ''}
                        </span>
                      </div>
                    </article>`;
                  },
                )}
              </div>
            </div>
          </section>
        `;
      };

      const ProfilePage = ({ params, onNavigateHome, onUpdateRange }) => {
        const userId = typeof params?.userId === 'string' && params.userId.trim().length > 0 ? params.userId.trim() : null;
        const [range, setRange] = useState(() => normalizeProfileRange(params ?? {}));
        const [draftSince, setDraftSince] = useState(() => toInputValue(range.sinceMs));
        const [draftUntil, setDraftUntil] = useState(() => toInputValue(range.untilMs));
        const [formError, setFormError] = useState('');
        const [state, setState] = useState({ status: 'idle', data: null, error: null });
        const [refreshNonce, setRefreshNonce] = useState(0);
        const previousUserRef = useRef(userId);

        useEffect(() => {
          const userChanged = previousUserRef.current !== userId;
          previousUserRef.current = userId;
          setRange((prev) => {
            const fallback = userChanged ? {} : prev || {};
            const normalized = normalizeProfileRange(params ?? {}, fallback);
            if (prev && normalized.sinceMs === prev.sinceMs && normalized.untilMs === prev.untilMs) {
              return prev;
            }
            return normalized;
          });
        }, [params?.since, params?.until, userId]);

        useEffect(() => {
          setDraftSince(toInputValue(range.sinceMs));
          setDraftUntil(toInputValue(range.untilMs));
        }, [range.sinceMs, range.untilMs]);

        useEffect(() => {
          if (!userId) {
            setState({ status: 'idle', data: null, error: null });
            return undefined;
          }

          const sinceMs = range.sinceMs;
          const untilMs = range.untilMs;
          if (!Number.isFinite(sinceMs) || !Number.isFinite(untilMs) || untilMs <= sinceMs) {
            return undefined;
          }

          const controller = typeof AbortController !== 'undefined' ? new AbortController() : null;
          setState((prev) => ({ status: 'loading', data: prev.data, error: null }));

          const fetchProfile = async () => {
            try {
              const query = new URLSearchParams();
              query.set('since', String(Math.floor(sinceMs)));
              query.set('until', String(Math.floor(untilMs)));
              const response = await fetch(`/api/users/${encodeURIComponent(userId)}/profile?${query.toString()}`, {
                signal: controller?.signal,
              });
              if (!response.ok) {
                let message = "Impossible de récupérer le profil demandé.";
                let shouldClear = false;
                try {
                  const body = await response.json();
                  if (body?.message) {
                    message = body.message;
                  }
                } catch (error) {
                  // ignore JSON parsing errors
                }
                if (response.status === 404) {
                  shouldClear = true;
                  message = 'Profil introuvable sur cette période.';
                }
                const error = new Error(message);
                error.clearData = shouldClear;
                throw error;
              }

              const payload = await response.json();
              setState({ status: 'success', data: payload, error: null });
            } catch (error) {
              if (error && typeof error === 'object' && error.name === 'AbortError') {
                return;
              }
              const message = error instanceof Error && error.message
                ? error.message
                : 'Impossible de récupérer le profil demandé.';
              const shouldClear = Boolean(error && typeof error === 'object' && error.clearData);
              setState((prev) => ({
                status: 'error',
                data: shouldClear ? null : prev.data,
                error: message,
              }));
            }
          };

          fetchProfile();
          return () => controller?.abort();
        }, [userId, range.sinceMs, range.untilMs, refreshNonce]);

        const handleBack = useCallback(
          (event) => {
            event?.preventDefault?.();
            if (typeof onNavigateHome === 'function') {
              onNavigateHome();
            }
          },
          [onNavigateHome],
        );

        const handlePresetClick = useCallback(
          (durationMs) => {
            if (!Number.isFinite(durationMs) || durationMs <= 0) {
              return;
            }
            const nowMs = Date.now();
            const nextUntil = nowMs;
            const nextSince = Math.max(0, nextUntil - durationMs);
            setRange({ sinceMs: nextSince, untilMs: nextUntil });
            setDraftSince(toInputValue(nextSince));
            setDraftUntil(toInputValue(nextUntil));
            setFormError('');
            if (typeof onUpdateRange === 'function' && userId) {
              onUpdateRange(userId, nextSince, nextUntil);
            }
          },
          [onUpdateRange, userId],
        );

        const handleApplyRange = useCallback(
          (event) => {
            event?.preventDefault?.();
            const sinceMs = parseRangeValue(draftSince);
            const untilMs = parseRangeValue(draftUntil);
            if (!Number.isFinite(sinceMs) || !Number.isFinite(untilMs)) {
              setFormError('Merci de renseigner deux dates valides.');
              return;
            }
            if (untilMs <= sinceMs) {
              setFormError('La date de fin doit être postérieure à la date de début.');
              return;
            }
            setFormError('');
            setRange({ sinceMs, untilMs });
            setDraftSince(toInputValue(sinceMs));
            setDraftUntil(toInputValue(untilMs));
            if (typeof onUpdateRange === 'function' && userId) {
              onUpdateRange(userId, sinceMs, untilMs);
            }
          },
          [draftSince, draftUntil, onUpdateRange, userId],
        );

        const handleRefresh = useCallback(() => {
          setRefreshNonce((value) => value + 1);
        }, []);

        const isLoading = state.status === 'loading';
        const errorMessage = state.status === 'error' ? state.error : null;
        const data = state.data;
        const activeRange = data?.range ?? range;
        const activeDuration = Number.isFinite(range.untilMs) && Number.isFinite(range.sinceMs)
          ? Math.abs(range.untilMs - range.sinceMs)
          : null;

        return html`
          <${Fragment}>
            <div class="flex items-center justify-between">
              <button
                type="button"
                onClick=${handleBack}
                class="inline-flex items-center gap-2 rounded-full border border-white/10 bg-white/5 px-3 py-1.5 text-xs font-semibold text-slate-200 transition hover:bg-white/10 hover:text-white"
              >
                <${ArrowLeft} class="h-4 w-4" aria-hidden="true" />
                Retour
              </button>
              ${userId
                ? html`<span class="text-xs uppercase tracking-[0.35em] text-slate-400">ID ${userId}</span>`
                : null}
            </div>

            ${!userId
              ? html`<section class="mt-6 space-y-4 rounded-3xl border border-white/10 bg-white/5 p-8 text-center shadow-xl shadow-slate-950/40 backdrop-blur-xl">
                  <h1 class="text-3xl font-semibold text-white">Profil introuvable</h1>
                  <p class="text-sm text-slate-300">Sélectionne un utilisateur depuis la page d'accueil pour afficher ses statistiques.</p>
                  <button
                    type="button"
                    onClick=${handleBack}
                    class="inline-flex items-center gap-2 rounded-full border border-white/10 bg-white/5 px-4 py-2 text-sm font-semibold text-slate-200 transition hover:bg-white/10 hover:text-white"
                  >
                    <${ArrowLeft} class="h-4 w-4" aria-hidden="true" />
                    Retour à l'accueil
                  </button>
                </section>`
              : html`
                  <div class="mt-6 grid gap-8">
                    <${ProfileIdentityCard} profile=${data?.profile ?? null} userId=${userId} />

                    <section class="rounded-3xl border border-white/10 bg-white/5 p-6 shadow-xl shadow-slate-950/40 backdrop-blur-xl">
                      <div class="flex flex-col gap-6">
                        <div class="flex flex-col gap-3 md:flex-row md:items-end md:justify-between">
                          <div>
                            <p class="text-xs uppercase tracking-[0.35em] text-indigo-200/80">Période analysée</p>
                            <h2 class="text-2xl font-semibold text-white">Filtrer l'activité</h2>
                            <p class="text-sm text-slate-300">${formatRangeLabel(range.sinceMs, range.untilMs)}</p>
                          </div>
                          <button
                            type="button"
                            onClick=${handleRefresh}
                            class=${[
                              'inline-flex items-center gap-2 rounded-full border border-white/10 px-3 py-1.5 text-xs font-semibold transition',
                              'bg-white/5 text-slate-200 hover:bg-white/10 hover:text-white',
                              isLoading ? 'opacity-60' : '',
                            ]
                              .filter(Boolean)
                              .join(' ')}
                            disabled=${isLoading}
                          >
                            <${RefreshCcw} class=${`h-4 w-4 ${isLoading ? 'animate-spin text-indigo-200' : ''}`} aria-hidden="true" />
                            Actualiser
                          </button>
                        </div>

                        <form class="grid gap-4 sm:grid-cols-[repeat(auto-fit,minmax(220px,1fr))]" onSubmit=${handleApplyRange}>
                          <label class="flex flex-col gap-2 text-sm text-slate-200">
                            <span>Depuis</span>
                            <input
                              type="datetime-local"
                              value=${draftSince}
                              onInput=${(event) => setDraftSince(event.currentTarget.value)}
                              class="w-full rounded-2xl border border-white/10 bg-slate-950/70 px-3 py-2 text-sm text-white shadow-inner shadow-black/20 focus:border-fuchsia-300 focus:outline-none focus:ring-1 focus:ring-fuchsia-300"
                              required
                            />
                          </label>
                          <label class="flex flex-col gap-2 text-sm text-slate-200">
                            <span>Jusqu'à</span>
                            <input
                              type="datetime-local"
                              value=${draftUntil}
                              onInput=${(event) => setDraftUntil(event.currentTarget.value)}
                              class="w-full rounded-2xl border border-white/10 bg-slate-950/70 px-3 py-2 text-sm text-white shadow-inner shadow-black/20 focus:border-fuchsia-300 focus:outline-none focus:ring-1 focus:ring-fuchsia-300"
                              required
                            />
                          </label>
                          <div class="flex items-end">
                            <button
                              type="submit"
                              class="inline-flex w-full items-center justify-center gap-2 rounded-2xl border border-fuchsia-400/60 bg-fuchsia-500/20 px-4 py-2 text-sm font-semibold text-fuchsia-100 transition hover:bg-fuchsia-500/30 hover:text-white"
                            >
                              Appliquer
                            </button>
                          </div>
                        </form>

                        <div class="flex flex-wrap gap-3 text-xs">
                          ${PROFILE_RANGE_PRESETS.map((preset) => {
                            const isActive = activeDuration != null && Math.abs(activeDuration - preset.durationMs) <= 60 * 1000;
                            const classes = [
                              'inline-flex items-center gap-2 rounded-full border px-3 py-1.5 font-semibold transition',
                              isActive
                                ? 'border-fuchsia-400/60 bg-fuchsia-500/20 text-white'
                                : 'border-white/10 bg-white/5 text-slate-200 hover:bg-white/10 hover:text-white',
                            ].join(' ');
                            return html`<button
                              key=${preset.label}
                              type="button"
                              class=${classes}
                              onClick=${() => handlePresetClick(preset.durationMs)}
                            >
                              ${preset.label}
                              <span class="sr-only">${preset.description}</span>
                            </button>`;
                          })}
                        </div>

                        ${formError
                          ? html`<p class="rounded-2xl border border-rose-400/40 bg-rose-500/10 px-4 py-2 text-xs text-rose-100">${formError}</p>`
                          : null}
                      </div>
                    </section>

                    ${errorMessage
                      ? html`<div class="rounded-3xl border border-rose-400/40 bg-rose-500/10 p-4 text-sm text-rose-100 shadow-lg shadow-rose-900/30">${errorMessage}</div>`
                      : null}

                    ${isLoading && !data
                      ? html`<div class="flex items-center gap-3 rounded-3xl border border-white/10 bg-white/5 p-4 text-sm text-slate-300">
                          <${RefreshCcw} class="h-4 w-4 animate-spin text-indigo-200" aria-hidden="true" />
                          Chargement du profil…
                        </div>`
                      : null}

                    ${data
                      ? html`
                          <${ProfileSummaryCards} stats=${data.stats} />
                          <${ProfileActivityTimeline}
                            range=${activeRange}
                            presenceSegments=${data.presenceSegments}
                            speakingSegments=${data.speakingSegments}
                            messageEvents=${data.messageEvents}
                          />
                          <${DailyBreakdown}
                            range=${activeRange}
                            presenceSegments=${data.presenceSegments}
                            speakingSegments=${data.speakingSegments}
                            messageEvents=${data.messageEvents}
                          />
                        `
                      : null}
                  </div>
                `}
          </${Fragment}>
        `;
      };

      const BanPage = () => html`
        <${Fragment}>
          <section class="space-y-6 rounded-3xl border border-white/10 bg-white/5 px-8 py-12 shadow-xl shadow-slate-950/40 backdrop-blur-xl">
            <p class="text-xs uppercase tracking-[0.35em] text-slate-300">Modération</p>
            <h1 class="text-4xl font-bold tracking-tight text-white sm:text-5xl">Actions de modération</h1>
            <p class="text-base leading-relaxed text-slate-200">
              Besoin d’écarter un fauteur de trouble sans casser l’ambiance ? Choisis la sanction la plus adaptée.
              Mute express ou bannissement encadré : l’équipe Libre Antenne se charge de l’exécution, du suivi et
              du rapport staff.
            </p>
            <div class="flex flex-wrap gap-3 text-xs text-slate-200">
              <span class="inline-flex items-center gap-2 rounded-full border border-white/15 bg-white/10 px-4 py-1.5">
                <${MicOff} class="h-4 w-4" aria-hidden="true" />
                Mise en sourdine express
              </span>
              <span class="inline-flex items-center gap-2 rounded-full border border-white/15 bg-white/10 px-4 py-1.5">
                <${ShieldCheck} class="h-4 w-4" aria-hidden="true" />
                Process encadré
              </span>
              <span class="inline-flex items-center gap-2 rounded-full border border-white/15 bg-white/10 px-4 py-1.5">
                <${Sparkles} class="h-4 w-4" aria-hidden="true" />
                Rapport modération inclus
              </span>
            </div>
          </section>

          <section class="space-y-6 rounded-3xl border border-indigo-400/30 bg-indigo-500/10 p-6 shadow-lg shadow-indigo-900/30 backdrop-blur">
            <div class="space-y-2">
              <p class="text-xs uppercase tracking-[0.35em] text-indigo-200">Nouvelle gamme</p>
              <h2 class="text-2xl font-semibold text-white">Gamme « Droits de modération »</h2>
              <p class="text-sm leading-relaxed text-indigo-100/80">
                Active à la demande les actions clés du staff pour garder le contrôle du salon vocal sans attendre.
              </p>
            </div>
            <ul class="grid gap-4 sm:grid-cols-2">
              <li class="flex items-start gap-3 rounded-2xl border border-white/10 bg-black/30 p-4">
                <span class="flex h-10 w-10 items-center justify-center rounded-full border border-indigo-400/40 bg-indigo-500/20 text-indigo-100">
                  <${MicOff} class="h-5 w-5" aria-hidden="true" />
                </span>
                <div class="space-y-1">
                  <p class="text-sm font-semibold text-white">Mute</p>
                  <p class="text-xs leading-relaxed text-slate-300">Coupure immédiate du micro pour stopper un débordement.</p>
                </div>
              </li>
              <li class="flex items-start gap-3 rounded-2xl border border-white/10 bg-black/30 p-4">
                <span class="flex h-10 w-10 items-center justify-center rounded-full border border-emerald-400/40 bg-emerald-500/20 text-emerald-100">
                  <${Mic} class="h-5 w-5" aria-hidden="true" />
                </span>
                <div class="space-y-1">
                  <p class="text-sm font-semibold text-white">Démute</p>
                  <p class="text-xs leading-relaxed text-slate-300">Restauration encadrée de la parole après validation du staff.</p>
                </div>
              </li>
              <li class="flex items-start gap-3 rounded-2xl border border-white/10 bg-black/30 p-4">
                <span class="flex h-10 w-10 items-center justify-center rounded-full border border-fuchsia-400/40 bg-fuchsia-500/20 text-fuchsia-100">
                  <${Users} class="h-5 w-5" aria-hidden="true" />
                </span>
                <div class="space-y-1">
                  <p class="text-sm font-semibold text-white">Expulser</p>
                  <p class="text-xs leading-relaxed text-slate-300">Éjection ciblée pour préserver la sécurité du vocal.</p>
                </div>
              </li>
              <li class="flex items-start gap-3 rounded-2xl border border-white/10 bg-black/30 p-4">
                <span class="flex h-10 w-10 items-center justify-center rounded-full border border-sky-400/40 bg-sky-500/20 text-sky-100">
                  <${Headphones} class="h-5 w-5" aria-hidden="true" />
                </span>
                <div class="space-y-1">
                  <p class="text-sm font-semibold text-white">Mute casque</p>
                  <p class="text-xs leading-relaxed text-slate-300">Silence le retour audio d’un membre sans couper son micro.</p>
                </div>
              </li>
              <li class="flex items-start gap-3 rounded-2xl border border-white/10 bg-black/30 p-4 sm:col-span-2">
                <span class="flex h-10 w-10 items-center justify-center rounded-full border border-rose-400/40 bg-rose-500/20 text-rose-100">
                  <${X} class="h-5 w-5" aria-hidden="true" />
                </span>
                <div class="space-y-1">
                  <p class="text-sm font-semibold text-white">Déconnecter</p>
                  <p class="text-xs leading-relaxed text-slate-300">Retire complètement du salon vocal les profils non conformes.</p>
                </div>
              </li>
            </ul>
          </section>

          <section class="grid gap-6 md:grid-cols-2 xl:grid-cols-3">
            ${MODERATION_SERVICES.map(
              (service) => html`<article
                key=${service.id}
                class="flex h-full flex-col rounded-3xl border border-white/10 bg-black/40 p-6 shadow-lg shadow-slate-950/40 backdrop-blur"
              >
                <p class="text-xs uppercase tracking-[0.35em] text-slate-300">${
                  service.categoryLabel || 'Option modération'
                }</p>
                <h3 class="mt-2 text-lg font-semibold text-white">${service.title}</h3>
                <p class="mt-3 text-sm leading-relaxed text-slate-300">${service.description}</p>
                <div class=${`mt-5 rounded-2xl border px-4 py-4 text-center ${service.accent}`}>
                  <p class="text-3xl font-bold text-white">${service.price}</p>
                  <p class="mt-1 text-xs uppercase tracking-[0.35em] text-slate-200">TTC</p>
                  <p class="sr-only">Tarif incluant la majoration de 10 %.</p>
                </div>
                <div class="mt-5 flex items-center gap-2 text-xs text-slate-400">
                  <${ShieldCheck} class="h-4 w-4 text-emerald-300" aria-hidden="true" />
                  <span>Application confirmée après validation avec le staff.</span>
                </div>
              </article>`,
            )}
          </section>

          <section class="grid gap-6 lg:grid-cols-2">
            <div class="space-y-4 rounded-3xl border border-white/10 bg-white/5 p-6 shadow-lg shadow-slate-950/40 backdrop-blur">
                <h2 class="flex items-center gap-2 text-xl font-semibold text-white">
                  <${ShieldCheck} class="h-5 w-5 text-emerald-300" aria-hidden="true" />
                  Comment ça marche ?
                </h2>
                <ol class="space-y-3 pl-5 text-sm leading-relaxed text-slate-200 marker:text-fuchsia-200">
                  <li>
                    Ouvre un ticket staff sur Discord en précisant le pseudo, la durée souhaitée et le motif de la sanction.
                  </li>
                  <li>
                    Règle le montant correspondant au palier choisi via la boutique (Stripe, PayPal ou CoinGate).
                  </li>
                  <li>
                    La modération applique l’action demandée, documente l’intervention et te confirme le suivi dans la foulée.
                  </li>
                </ol>
              </div>
              <div class="space-y-4 rounded-3xl border border-white/10 bg-slate-950/60 p-6 shadow-lg shadow-slate-950/50 backdrop-blur">
                <h2 class="flex items-center gap-2 text-xl font-semibold text-white">
                  <${AlertCircle} class="h-5 w-5 text-amber-300" aria-hidden="true" />
                  Bon à savoir
                </h2>
                <ul class="space-y-3 text-sm leading-relaxed text-slate-200">
                  <li>
                    Les durées sont cumulables si la situation exige une sanction plus longue que le barème standard.
                  </li>
                  <li>
                    Aucune action n’est appliquée sans trace écrite : un log privé reste disponible pour l’équipe.
                  </li>
                  <li>
                    En cas de litige, le staff se réserve le droit de prolonger ou d’annuler la sanction après enquête.
                  </li>
                </ul>
              </div>
            </section>

          <section class="rounded-3xl border border-white/10 bg-black/50 p-6 shadow-lg shadow-slate-950/40 backdrop-blur">
            <div class="flex flex-col gap-4 md:flex-row md:items-center md:justify-between">
              <div class="space-y-2">
                <h2 class="text-xl font-semibold text-white">Prêt à lancer une action de modération ?</h2>
                <p class="text-sm leading-relaxed text-slate-300">
                  Contacte immédiatement la modération pour confirmer les détails et sécuriser la communauté.
                </p>
              </div>
              <a
                class="inline-flex items-center gap-2 rounded-full border border-fuchsia-400/50 bg-fuchsia-500/20 px-5 py-2 text-sm font-semibold text-fuchsia-100 shadow-lg shadow-fuchsia-900/30 transition hover:bg-fuchsia-500/30 hover:text-white"
                href="https://discord.gg/btjTZ5C"
                target="_blank"
                rel="noopener noreferrer"
              >
                Contacter la modération
                <${ArrowRight} class="h-4 w-4" aria-hidden="true" />
              </a>
            </div>
          </section>
        </${Fragment}>
      `;

      const AboutPage = () => html`
        <${Fragment}>
          <section class="space-y-6 rounded-3xl border border-white/10 bg-white/5 px-8 py-12 shadow-xl shadow-slate-950/40 backdrop-blur-xl">
            <p class="text-xs uppercase tracking-[0.35em] text-slate-300">Libre Antenne</p>
            <h1 class="text-4xl font-bold tracking-tight text-white sm:text-5xl">À propos de Libre Antenne</h1>
            <p class="text-base leading-relaxed text-slate-200">
              Libre Antenne est une zone franche où les voix prennent le pouvoir. Le flux est volontairement brut,
              capté en direct sur notre serveur Discord pour amplifier les histoires, les confidences et les improvisations qui
              naissent.
            </p>
            <p class="text-base leading-relaxed text-slate-200">
              Notre équipe façonne un espace accueillant pour les marginaux créatifs, les gamers insomniaques et toutes les
              personnes qui ont besoin d’un micro ouvert. Ici, aucune intervention n’est scriptée : la seule règle est de
              respecter la vibe collective et de laisser la spontanéité guider la conversation.
            </p>
          </section>

          <section class="grid gap-6 md:grid-cols-2">
            <div class="rounded-3xl border border-white/10 bg-slate-950/60 p-6 shadow-lg shadow-slate-950/40 backdrop-blur">
              <h2 class="text-xl font-semibold text-white">Un laboratoire</h2>
              <p class="mt-3 text-sm text-slate-300">
                Sessions freestyle, confessions lunaires, débats improvisés : chaque passage est un moment unique façonné par la
                communauté. Le direct nous permet de capturer cette énergie sans filtre.
              </p>
            </div>
            <div class="rounded-3xl border border-white/10 bg-slate-950/60 p-6 shadow-lg shadow-slate-950/40 backdrop-blur">
              <h2 class="text-xl font-semibold text-white">Technologie artisanale</h2>
              <p class="mt-3 text-sm text-slate-300">
                Notre mixeur audio fait circuler chaque voix avec finesse. Les outils open source et les contributions des
                membres permettent d’améliorer constamment la qualité du flux.
              </p>
            </div>
            <div class="rounded-3xl border border-white/10 bg-slate-950/60 p-6 shadow-lg shadow-slate-950/40 backdrop-blur">
              <h2 class="text-xl font-semibold text-white">Communauté inclusive</h2>
              <p class="mt-3 text-sm text-slate-300">
                Peu importe ton accent, ton parcours ou ton rythme de vie : tu es accueilli·e tant que tu joues collectif et que
                tu respectes les autres intervenants.
              </p>
            </div>
            <div class="rounded-3xl border border-white/10 bg-slate-950/60 p-6 shadow-lg shadow-slate-950/40 backdrop-blur">
              <h2 class="text-xl font-semibold text-white">Programmation souple</h2>
              <p class="mt-3 text-sm text-slate-300">
                Les créneaux sont ouverts : tu peux proposer un sujet, lancer un atelier ou simplement écouter. Le planning
                évolue selon les envies du moment.
              </p>
            </div>
          </section>

          <section class="rounded-3xl border border-fuchsia-500/30 bg-fuchsia-500/10 px-8 py-10 text-center shadow-xl shadow-fuchsia-900/30 backdrop-blur">
            <h2 class="text-2xl font-semibold text-white">Rejoins la fréquence</h2>
            <p class="mt-3 text-sm text-fuchsia-100">
              Connecte-toi sur Discord pour proposer ta voix, écouter les autres et faire grandir l’expérience Libre Antenne.
              La scène t’attend.
            </p>
            <a
              class="mt-6 inline-flex items-center gap-2 rounded-full border border-white/40 bg-white/10 px-5 py-2 text-sm font-semibold text-white transition hover:bg-white/20"
              href="https://discord.gg/btjTZ5C"
              target="_blank"
              rel="noopener noreferrer"
            >
              Rejoindre le Discord
              <${ArrowRight} class="h-4 w-4" aria-hidden="true" />
            </a>
          </section>
        </${Fragment}>
      `;

      const getInitialSoulDecision = () => {
        if (typeof window === 'undefined') {
          return null;
        }
        try {
          return window.localStorage?.getItem('soulContract') ?? null;
        } catch (error) {
          console.warn("Impossible de lire le pacte d'âme", error);
          return null;
        }
      };

      const App = () => {
        const [status, setStatus] = useState('connecting');
        const [participantsMap, setParticipantsMap] = useState(() => new Map());
        const [speakingHistory, setSpeakingHistory] = useState(() => []);
        const [selectedWindowMinutes, setSelectedWindowMinutes] = useState(DEFAULT_WINDOW_MINUTES);
        const participantsRef = useRef(new Map());
        const [streamInfo, setStreamInfo] = useState({ path: '/stream', format: 'opus', mimeType: 'audio/ogg' });
        const [lastUpdate, setLastUpdate] = useState(null);
        const [now, setNow] = useState(Date.now());
        const [menuOpen, setMenuOpen] = useState(false);
        const [route, setRoute] = useState(() => getRouteFromHash());
        const [anonymousSlot, setAnonymousSlot] = useState(() => normalizeAnonymousSlot());
        const [soulDecision, setSoulDecision] = useState(getInitialSoulDecision);
        const [showSoulModal, setShowSoulModal] = useState(() => !getInitialSoulDecision());
        const [soulMessage, setSoulMessage] = useState('');

        useEffect(() => {
          const id = setInterval(() => setNow(Date.now()), 1000);
          return () => clearInterval(id);
        }, []);

        useEffect(() => {
          if (!window.location.hash) {
            window.location.hash = '#/';
            setRoute({ name: 'home', params: {} });
          }
        }, []);

        const updateProfileRoute = useCallback(
          (userId, sinceMs, untilMs, options = {}) => {
            if (!userId) {
              return;
            }
            const sinceParam = Number.isFinite(sinceMs) ? String(Math.floor(sinceMs)) : null;
            const untilParam = Number.isFinite(untilMs) ? String(Math.floor(untilMs)) : null;
            const nextRoute = { name: 'profile', params: { userId, since: sinceParam, until: untilParam } };
            const nextHash = buildProfileHash(userId, sinceMs, untilMs);
            if (window.location.hash !== nextHash) {
              window.location.hash = nextHash;
            }
            setRoute(nextRoute);
            if (options.scrollToTop) {
              window.scrollTo({ top: 0, behavior: 'smooth' });
            }
          },
          [setRoute],
        );

        const handleProfileOpen = useCallback(
          (userId) => {
            updateProfileRoute(userId, null, null, { scrollToTop: true });
          },
          [updateProfileRoute],
        );

        useEffect(() => {
          const updateRoute = () => setRoute(getRouteFromHash());
          window.addEventListener('hashchange', updateRoute);
          return () => window.removeEventListener('hashchange', updateRoute);
        }, []);

        useEffect(() => {
          setMenuOpen(false);
        }, [route]);

        useEffect(() => {
          participantsRef.current = participantsMap;
        }, [participantsMap]);

        useEffect(() => {
          if (soulDecision) {
            setShowSoulModal(false);
          } else {
            setShowSoulModal(true);
          }
        }, [soulDecision]);

        useEffect(() => {
          if (!soulMessage) {
            return undefined;
          }
          const timer = setTimeout(() => setSoulMessage(''), 5000);
          return () => clearTimeout(timer);
        }, [soulMessage]);

        useEffect(() => {
          let cancelled = false;
          const controller = typeof AbortController !== 'undefined' ? new AbortController() : null;

          const parseTimestamp = (input) => {
            const numeric = Number(input);
            if (Number.isFinite(numeric)) {
              return numeric;
            }
            if (typeof input === 'string') {
              const parsed = new Date(input);
              const ms = parsed.getTime();
              if (!Number.isNaN(ms)) {
                return ms;
              }
            }
            return null;
          };

          const fetchHistory = async () => {
            const params = new URLSearchParams();
            const sinceTs = Date.now() - HISTORY_RETENTION_MS;
            if (Number.isFinite(sinceTs)) {
              params.set('since', String(Math.floor(sinceTs)));
            }

            const query = params.toString();
            const url = query ? `/api/voice-activity/history?${query}` : '/api/voice-activity/history';

            try {
              const response = await fetch(url, controller ? { signal: controller.signal } : undefined);
              if (!response.ok) {
                throw new Error(`HTTP ${response.status}`);
              }
              const payload = await response.json();
              if (cancelled) {
                return;
              }

              const segments = Array.isArray(payload?.segments) ? payload.segments : [];
              if (!segments.length) {
                return;
              }

              const nowTs = Date.now();
              setSpeakingHistory((prev) => {
                const normalized = segments
                  .map((segment) => {
                    if (!segment || typeof segment !== 'object') {
                      return null;
                    }
                    const rawId = typeof segment.userId === 'string' && segment.userId
                      ? segment.userId
                      : typeof segment.id === 'string'
                      ? segment.id
                      : null;
                    if (!rawId) {
                      return null;
                    }

                    const start = parseTimestamp(
                      Object.prototype.hasOwnProperty.call(segment, 'startedAtMs')
                        ? segment.startedAtMs
                        : segment.startedAt,
                    );
                    if (typeof start !== 'number') {
                      return null;
                    }

                    const end = parseTimestamp(
                      Object.prototype.hasOwnProperty.call(segment, 'endedAtMs')
                        ? segment.endedAtMs
                        : segment.endedAt,
                    );

                    const durationValue = Number(segment.durationMs);
                    const durationMs = Number.isFinite(durationValue) ? Math.max(durationValue, 0) : null;

                    let resolvedEnd = typeof end === 'number' ? end : null;
                    if (resolvedEnd == null && durationMs != null) {
                      resolvedEnd = start + durationMs;
                    }

                    if (typeof resolvedEnd !== 'number' || Number.isNaN(resolvedEnd) || resolvedEnd <= start) {
                      return null;
                    }

                    const profile =
                      segment.profile && typeof segment.profile === 'object'
                        ? sanitizeProfile(segment.profile)
                        : { displayName: null, username: null, avatar: null };

                    return {
                      id: rawId,
                      start,
                      end: resolvedEnd,
                      profile,
                    };
                  })
                  .filter(Boolean);

                if (!normalized.length) {
                  return prev;
                }

                const combined = [...prev, ...normalized];
                return sortSegments(trimSegments(combined, nowTs));
              });
            } catch (error) {
              if (error && error.name === 'AbortError') {
                return;
              }
              console.warn("Impossible de récupérer l'historique vocal", error);
            }
          };

          fetchHistory();

          return () => {
            cancelled = true;
            if (controller) {
              controller.abort();
            }
          };
        }, []);

        const handleWindowChange = useCallback((minutes) => {
          if (!Number.isFinite(minutes)) {
            return;
          }
          const normalized = TALK_WINDOW_OPTIONS.includes(minutes) ? minutes : DEFAULT_WINDOW_MINUTES;
          setSelectedWindowMinutes(normalized);
        }, []);

        const handleSoulDecision = useCallback((accepted) => {
          const choice = accepted ? 'accepted' : 'declined';
          setSoulDecision(choice);
          try {
            if (typeof window !== 'undefined' && window.localStorage) {
              window.localStorage.setItem('soulContract', choice);
            }
          } catch (error) {
            console.warn("Impossible de stocker le pacte d'âme", error);
          }
          setSoulMessage(
            accepted
              ? "Merci pour ta confiance éternelle. Le dieu 8.6 t'offrira peut-être une tournée. 🍻"
              : 'Refus enregistré. Tu gardes ton âme, mais reste pour la musique !'
          );
          setShowSoulModal(false);
        }, []);

        useEffect(() => {
          const source = new EventSource('/events');
          source.onopen = () => setStatus('connected');
          source.onerror = () => {
            if (source.readyState === EventSource.CONNECTING) {
              setStatus('reconnecting');
            } else if (source.readyState === EventSource.CLOSED) {
              setStatus('error');
            }
          };

          const applyState = (payload) => {
            if (!payload || typeof payload !== 'object') {
              return;
            }

            if (Array.isArray(payload.speakers)) {
              const nowTs = Date.now();
              const previous = participantsRef.current;
              const next = new Map();
              const speakingSnapshot = new Map();

              for (const speaker of payload.speakers) {
                if (!speaker?.id) continue;
                const normalized = {
                  ...speaker,
                  voiceState: speaker.voiceState ?? {},
                  isSpeaking: Boolean(speaker.isSpeaking),
                };
                next.set(speaker.id, normalized);
                if (normalized.isSpeaking) {
                  speakingSnapshot.set(speaker.id, normalized);
                }
              }

              participantsRef.current = next;
              setParticipantsMap(next);
              setSpeakingHistory((prev) => {
                let segments = trimSegments(prev, nowTs);
                if (previous instanceof Map) {
                  previous.forEach((participant, id) => {
                    if (participant?.isSpeaking && !speakingSnapshot.has(id)) {
                      segments = closeOpenSegment(segments, id, nowTs, participant);
                    }
                  });
                }
                speakingSnapshot.forEach((participant, id) => {
                  segments = ensureOpenSegment(segments, id, participant.startedAt ?? nowTs, participant);
                });
                return sortSegments(trimSegments(segments, nowTs));
              });
              setLastUpdate(nowTs);
            }

            if (Object.prototype.hasOwnProperty.call(payload, 'anonymousSlot')) {
              setAnonymousSlot(normalizeAnonymousSlot(payload.anonymousSlot));
            }
          };

          source.addEventListener('state', (event) => {
            try {
              const data = JSON.parse(event.data);
              applyState(data);
            } catch (err) {
              console.error('state event parse error', err);
            }
          });

          source.addEventListener('speaking', (event) => {
            try {
              const data = JSON.parse(event.data);
              if (data?.type === 'start' && data.user?.id) {
                const user = data.user;
                const userId = user.id;
                const eventNow = Date.now();
                const startTime = Number.isFinite(user.startedAt) ? user.startedAt : eventNow;
                setParticipantsMap((prev) => {
                  const next = new Map(prev);
                  const existing = next.get(userId) || { voiceState: {} };
                  const updated = {
                    ...existing,
                    ...user,
                    isSpeaking: true,
                    voiceState: user.voiceState ?? existing.voiceState ?? {},
                  };
                  next.set(userId, updated);
                  participantsRef.current = next;
                  return next;
                });
                setSpeakingHistory((prev) => {
                  let segments = trimSegments(prev, eventNow);
                  segments = ensureOpenSegment(segments, userId, startTime, user);
                  return sortSegments(trimSegments(segments, eventNow));
                });
                setLastUpdate(eventNow);
              } else if (data?.type === 'end') {
                const targetId = data.user?.id ?? data.userId;
                if (targetId) {
                  const eventNow = Date.now();
                  const endTimestamp = Number.isFinite(data.user?.lastSpokeAt) ? data.user.lastSpokeAt : eventNow;
                  setParticipantsMap((prev) => {
                    const next = new Map(prev);
                    const existing = next.get(targetId);
                    if (!existing) {
                      return prev;
                    }
                    const updated = {
                      ...existing,
                      ...data.user,
                      isSpeaking: false,
                      voiceState: (data.user && data.user.voiceState) ?? existing.voiceState ?? {},
                      lastSpokeAt: data.user?.lastSpokeAt ?? eventNow,
                    };
                    next.set(targetId, updated);
                    participantsRef.current = next;
                    return next;
                  });
                  setSpeakingHistory((prev) => {
                    let segments = trimSegments(prev, eventNow);
                    segments = closeOpenSegment(segments, targetId, endTimestamp, data.user ?? {}, { createIfMissing: true });
                    return sortSegments(trimSegments(segments, eventNow));
                  });
                  setLastUpdate(eventNow);
                }
              }
            } catch (err) {
              console.error('speaking event parse error', err);
            }
          });

          source.addEventListener('info', (event) => {
            try {
              const data = JSON.parse(event.data);
              setStreamInfo((prev) => ({
                path: data?.path ?? prev.path,
                format: data?.format ?? prev.format,
                mimeType: data?.mimeType ?? prev.mimeType,
              }));
            } catch (err) {
              console.error('info event parse error', err);
            }
          });

          source.addEventListener('anonymous-slot', (event) => {
            try {
              const data = JSON.parse(event.data);
              setAnonymousSlot(normalizeAnonymousSlot(data));
            } catch (err) {
              console.error('anonymous slot event parse error', err);
            }
          });

          return () => source.close();
        }, []);
        const speakers = useMemo(() => {
          const values = Array.from(participantsMap.values()).map((participant) => ({
            ...participant,
            voiceState: participant.voiceState ?? {},
          }));
          values.sort((a, b) => {
            const nameA = (a.displayName || a.username || '').trim();
            const nameB = (b.displayName || b.username || '').trim();
            const normalizedA = nameA.toLocaleLowerCase('fr-FR');
            const normalizedB = nameB.toLocaleLowerCase('fr-FR');
            const nameComparison = normalizedA.localeCompare(normalizedB, 'fr', {
              sensitivity: 'base',
            });
            if (nameComparison !== 0) {
              return nameComparison;
            }
            const idA = String(a.id ?? '');
            const idB = String(b.id ?? '');
            return idA.localeCompare(idB);
          });
          return values;
        }, [participantsMap]);

        const lastUpdateLabel = lastUpdate ? formatRelative(lastUpdate, now) : 'Synchronisation…';
        const audioKey = `${streamInfo.path}|${streamInfo.mimeType}`;

        const handleNavigate = (event, targetRoute) => {
          event.preventDefault();
          const link = NAV_LINKS.find((entry) => entry.route === targetRoute);
          if (!link) {
            return;
          }
          if (link.external && link.href) {
            window.location.href = link.href;
            setMenuOpen(false);
            return;
          }
          if (window.location.hash !== link.hash) {
            window.location.hash = link.hash;
          } else {
            setRoute({ name: targetRoute, params: {} });
          }
          setMenuOpen(false);
          window.scrollTo({ top: 0, behavior: 'smooth' });
        };

        return html`
          <div class="relative flex min-h-screen flex-col overflow-hidden">
            ${
              showSoulModal
                ? html`<div class="fixed inset-0 z-50 flex items-center justify-center bg-slate-950/80 px-6 backdrop-blur-sm">
                    <div class="w-full max-w-xl overflow-hidden rounded-3xl border border-fuchsia-400/30 bg-slate-900/80 p-8 text-center shadow-2xl shadow-fuchsia-900/50">
                      <div class="mb-4 inline-flex items-center justify-center rounded-full bg-fuchsia-500/20 px-4 py-1 text-xs font-semibold uppercase tracking-[0.35em] text-fuchsia-200">
                        Pacte sacré
                      </div>
                      <h2 class="text-3xl font-bold text-white">Avant d'entrer…</h2>
                      <p class="mt-4 text-base leading-relaxed text-slate-200">
                        Acceptes-tu solennellement de <span class="font-semibold text-fuchsia-200">vendre ton âme au diable</span>
                        et de prier le très pétillant <span class="font-semibold text-amber-200">dieu 8.6</span> à chaque lever de canette ?
                      </p>
                      <p class="mt-3 text-sm text-slate-300">
                        (Promis, c'est surtout pour l'ambiance. Les démons adorent les vibes chill.)
                      </p>
                      <div class="mt-8 flex flex-col gap-3 sm:flex-row sm:justify-center">
                        <button
                          type="button"
                          class="w-full rounded-full border border-emerald-400/40 bg-emerald-400/20 px-6 py-3 text-sm font-semibold uppercase tracking-[0.2em] text-emerald-100 transition hover:bg-emerald-400/30 hover:text-white sm:w-auto"
                          onClick=${() => handleSoulDecision(true)}
                        >
                          J'offre mon âme (et une tournée)
                        </button>
                        <button
                          type="button"
                          class="w-full rounded-full border border-slate-400/40 bg-slate-800/60 px-6 py-3 text-sm font-semibold uppercase tracking-[0.2em] text-slate-200 transition hover:bg-slate-700/60 hover:text-white sm:w-auto"
                          onClick=${() => handleSoulDecision(false)}
                        >
                          Nope, je suis team libre arbitre
                        </button>
                      </div>
                    </div>
                  </div>`
                : null
            }
            ${
              soulMessage
                ? html`<div class="fixed bottom-6 left-1/2 z-40 w-full max-w-md -translate-x-1/2 rounded-2xl border border-white/15 bg-slate-900/80 px-5 py-3 text-center text-sm text-slate-100 shadow-lg shadow-fuchsia-900/40 backdrop-blur">
                    ${soulMessage}
                  </div>`
                : null
            }
            <div class="pointer-events-none absolute inset-0 overflow-hidden">
              <div class="absolute -left-24 -top-24 h-[24rem] w-[24rem] rounded-full bg-indigo-500/30 blur-3xl"></div>
              <div class="absolute -right-20 bottom-[-8rem] h-[28rem] w-[28rem] rounded-full bg-fuchsia-500/25 blur-[120px]"></div>
              <div class="absolute inset-0 bg-[radial-gradient(circle_at_top,_rgba(99,102,241,0.08)_0,_transparent_55%)]"></div>
            </div>
            <div class="relative z-10 flex flex-1 flex-col">
              <header class="sticky top-0 z-20 border-b border-white/10 bg-slate-950/70 backdrop-blur">
                <div class="mx-auto flex max-w-5xl items-center justify-between px-6 py-4 sm:px-10">
                  <a
                    href="#/"
                    class="text-base font-semibold uppercase tracking-[0.35em] text-slate-200 transition hover:text-white"
                    onClick=${(event) => handleNavigate(event, 'home')}
                  >
                    Libre Antenne
                  </a>
                  <nav class="hidden items-center gap-6 md:flex">
                    ${NAV_LINKS.map((link) =>
                      html`
                        <a
                          key=${link.route}
                          href=${link.external && link.href ? link.href : link.hash}
                          onClick=${(event) => handleNavigate(event, link.route)}
                          aria-current=${route.name === link.route ? 'page' : undefined}
                          class=${`text-sm font-semibold transition hover:text-white ${
                            route.name === link.route ? 'text-white' : 'text-slate-300'
                          }`}
                        >
                          ${link.label}
                        </a>
                      `
                    )}
                  </nav>
                  <button
                    type="button"
                    class="inline-flex h-10 w-10 items-center justify-center rounded-full border border-white/20 bg-white/5 text-slate-200 transition hover:border-white/40 hover:text-white md:hidden"
                    aria-label=${menuOpen ? 'Fermer le menu' : 'Ouvrir le menu'}
                    aria-expanded=${menuOpen}
                    onClick=${() => setMenuOpen((prev) => !prev)}
                  >
                    ${
                      menuOpen
                        ? html`<${X} class="h-5 w-5" aria-hidden="true" />`
                        : html`<${Menu} class="h-5 w-5" aria-hidden="true" />`
                    }
                  </button>
                </div>
                ${
                  menuOpen
                    ? html`
                        <div class="border-t border-white/10 px-6 pb-6 pt-4 sm:px-10 md:hidden">
                          <nav class="flex flex-col gap-3">
                            ${NAV_LINKS.map((link) =>
                              html`
                                <a
                                  key=${`mobile-${link.route}`}
                                  href=${link.external && link.href ? link.href : link.hash}
                                  onClick=${(event) => handleNavigate(event, link.route)}
                                  class=${`rounded-full border border-white/10 bg-white/5 px-4 py-2 text-sm font-semibold transition hover:bg-white/10 hover:text-white ${
                                    route.name === link.route ? 'text-white' : 'text-slate-200'
                                  }`}
                                >
                                  ${link.label}
                                </a>
                              `
                            )}
                          </nav>
                        </div>
                      `
                    : null
                }
              </header>

              <main class="flex-1 px-6 pb-16 pt-8 sm:px-10">
                <div class="mx-auto flex max-w-5xl flex-col gap-10">
                  ${
                    route.name === 'ban'
                      ? html`<${BanPage} />`
                      : route.name === 'about'
                      ? html`<${AboutPage} />`
                      : route.name === 'members'
                      ? html`<${MembersPage} onViewProfile=${handleProfileOpen} />`
                      : route.name === 'shop'
                      ? html`<${ShopPage} />`
                      : route.name === 'profile'
                      ? html`<${ProfilePage}
                          params=${route.params}
                          onNavigateHome=${() => {
                            window.location.hash = '#/';
                            setRoute({ name: 'home', params: {} });
                          }}
                          onUpdateRange=${updateProfileRoute}
                        />`
                      : html`<${HomePage}
                          status=${status}
                          lastUpdateLabel=${lastUpdateLabel}
                          streamInfo=${streamInfo}
                          audioKey=${audioKey}
                          speakers=${speakers}
                          now=${now}
                          anonymousSlot=${anonymousSlot}
                          speakingHistory=${speakingHistory}
                          selectedWindowMinutes=${selectedWindowMinutes}
                          onWindowChange=${handleWindowChange}
                          onViewProfile=${handleProfileOpen}
                        />`
                  }
                </div>
              </main>

              <footer class="px-6 pb-10 text-center text-xs text-slate-500 sm:px-10">
                Libre Antenne · Tous droits réservés
              </footer>
            </div>
          </div>
        `;
      };
      render(html`<${App} />`, document.getElementById('app'));
    </script>
    <script>
      if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
          navigator.serviceWorker
            .register('/sw.js')
            .then((registration) => {
              console.info('Service worker enregistré', registration.scope);
            })
            .catch((error) => {
              console.warn('Service worker introuvable', error);
            });
        });
      }
    </script>
    <button
      id="test-beep-trigger"
      type="button"
      aria-label="Déclencher un bip de test"
      title="Bip test bot"
      class="fixed bottom-2 right-2 z-40 h-12 w-12 rounded-full border border-white/10 bg-white/20 opacity-20 transition duration-150 ease-out hover:opacity-60 focus-visible:opacity-70 focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-white/40"
    ></button>
    <script>
      (() => {
        const button = document.getElementById('test-beep-trigger');
        if (!button) {
          return;
        }

        let pending = false;
        button.addEventListener('click', async () => {
          if (pending) {
            return;
          }

          pending = true;
          const previousOpacity = button.style.opacity;
          button.style.opacity = '0.65';

          try {
            const response = await fetch('/test-beep', { method: 'POST' });
            if (!response.ok) {
              console.warn('Réponse inattendue pour le bip de test', response.status);
            }
          } catch (error) {
            console.warn('Impossible de déclencher le bip de test', error);
          } finally {
            setTimeout(() => {
              button.style.opacity = previousOpacity;
            }, 150);
            pending = false;
          }
        });
      })();
    </script>
  </body>
</html>
