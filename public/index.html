<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Libre Antenne</title>
    <meta
      name="description"
      content="Le chaos en direct : un refuge sans filtre pour drogués, marginaux, alcooliques, gamers et esprits libres."
    />
    <meta name="keywords" content="radio libre, libre antenne, talk show en direct, discord audio, streaming communautaire" />
    <meta name="robots" content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1" />
    <meta name="googlebot" content="index, follow" />
    <meta name="bingbot" content="index, follow" />
    <meta name="referrer" content="no-referrer-when-downgrade" />
    <meta name="author" content="Libre Antenne" />
    <meta name="publisher" content="Libre Antenne" />
    <meta name="theme-color" content="#020617" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta name="application-name" content="Libre Antenne" />
    <meta name="apple-mobile-web-app-title" content="Libre Antenne" />
    <link rel="canonical" href="https://libre-antenne.xyz/" />
    <link rel="alternate" href="https://libre-antenne.xyz/" hreflang="fr-FR" />
    <link rel="manifest" href="/site.webmanifest" />
    <link rel="icon" type="image/svg+xml" href="/icons/icon-192.svg" />
    <link rel="apple-touch-icon" sizes="192x192" href="/icons/icon-192.svg" />
    <link rel="dns-prefetch" href="https://fonts.googleapis.com" />
    <link rel="dns-prefetch" href="https://fonts.gstatic.com" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      rel="preload"
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap"
      as="style"
      onload="this.onload=null;this.rel='stylesheet'"
    />
    <noscript>
      <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap"
        rel="stylesheet"
      />
    </noscript>
    <meta property="og:type" content="website" />
    <meta property="og:locale" content="fr_FR" />
    <meta property="og:url" content="https://libre-antenne.xyz/" />
    <meta property="og:site_name" content="Libre Antenne" />
    <meta property="og:title" content="Libre Antenne · Radio libre et streaming communautaire" />
    <meta
      property="og:description"
      content="Libre Antenne diffuse en continu les voix du salon Discord : un espace sans filtre pour les esprits libres, les joueurs et les noctambules."
    />
    <meta property="og:image" content="https://libre-antenne.xyz/icons/icon-512.png" />
    <meta property="og:image:alt" content="Illustration du direct communautaire Libre Antenne" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:site" content="@libreantenne" />
    <meta name="twitter:creator" content="@libreantenne" />
    <meta name="twitter:title" content="Libre Antenne · Radio libre et streaming communautaire" />
    <meta
      name="twitter:description"
      content="Rejoins le flux audio Libre Antenne pour partager ta voix en direct et écouter la communauté."
    />
    <meta name="twitter:image" content="https://libre-antenne.xyz/icons/icon-512.png" />
    <script src="https://cdn.tailwindcss.com?plugins=forms,typography,aspect-ratio" defer></script>
    <script type="application/ld+json">
      {
        "@context": "https://schema.org",
        "@type": "BroadcastService",
        "name": "Libre Antenne",
        "description": "Flux audio communautaire en direct diffusé depuis Discord, libre d'accès et sans filtre.",
        "url": "https://libre-antenne.xyz/",
        "areaServed": "FR",
        "inLanguage": "fr-FR",
        "provider": {
          "@type": "Organization",
          "name": "Libre Antenne",
          "url": "https://libre-antenne.xyz/"
        },
        "broadcastDisplayName": "Libre Antenne – Direct Discord",
        "broadcastFrequency": "Streaming en ligne",
        "sameAs": [
          "https://discord.com/",
          "https://twitter.com/libreantenne"
        ]
      }
    </script>
    <script>
      tailwind.config = {
        theme: {
          extend: {
            fontFamily: {
              sans: ['Inter', 'system-ui', 'sans-serif'],
            },
            boxShadow: {
              glow: '0 0 50px rgba(129, 140, 248, 0.35)',
            },
          },
        },
      };
    </script>
    <style>
      body {
        font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      }

      .speaker-card {
        opacity: 0;
        transform: translateY(24px) scale(0.97);
        animation: speaker-fade-in 1.25s cubic-bezier(0.16, 1, 0.3, 1) forwards;
        will-change: transform, opacity;
        transition: opacity 0.4s ease, transform 0.4s ease;
      }

      .speaker-card[data-state='idle'] {
        opacity: 0.92;
      }

      .speaker-card[data-state='speaking'] {
        opacity: 1;
      }

      @keyframes speaker-fade-in {
        0% {
          opacity: 0;
          transform: translateY(24px) scale(0.97);
        }

        35% {
          opacity: 0.55;
          transform: translateY(14px) scale(0.985);
        }

        70% {
          opacity: 0.9;
          transform: translateY(4px) scale(1.01);
        }

        100% {
          opacity: 1;
          transform: translateY(0) scale(1);
        }
      }

      @keyframes player-eq {
        0%,
        100% {
          transform: scaleY(0.45);
          opacity: 0.6;
        }

        50% {
          transform: scaleY(1);
          opacity: 1;
        }
      }

      .audio-wave span {
        animation: player-eq 1.2s ease-in-out infinite;
        transform-origin: center bottom;
        display: inline-block;
        width: 0.3rem;
        border-radius: 9999px;
      }

      .audio-wave span:nth-child(2) {
        animation-delay: 0.2s;
      }

      .audio-wave span:nth-child(3) {
        animation-delay: 0.4s;
      }

      .audio-wave span:nth-child(4) {
        animation-delay: 0.6s;
      }

      .mic-meter {
        position: relative;
        height: 0.6rem;
        border-radius: 9999px;
        background: rgba(148, 163, 184, 0.18);
        overflow: hidden;
      }

      .mic-meter-bar {
        position: absolute;
        inset: 0;
        width: 0%;
        background: linear-gradient(90deg, rgba(129, 140, 248, 0.9), rgba(236, 72, 153, 0.95));
        box-shadow: 0 0 30px rgba(236, 72, 153, 0.4);
        transition: width 0.18s cubic-bezier(0.16, 1, 0.3, 1);
      }
    </style>
  </head>
  <body class="min-h-screen bg-slate-950 text-slate-100 antialiased">
    <div id="app" class="min-h-screen"></div>

    <script type="module">
      import { h, render, Fragment } from 'https://esm.sh/preact@10.19.2';
      import { useCallback, useEffect, useLayoutEffect, useMemo, useRef, useState } from 'https://esm.sh/preact@10.19.2/hooks';
      import {
        Activity,
        AlertCircle,
        ArrowRight,
        Clock3,
        Headphones,
        Menu,
        Mic,
        MicOff,
        MonitorPlay,
        Pause,
        Play,
        RefreshCcw,
        ShieldCheck,
        Users,
        Video,
        Volume,
        Volume1,
        Volume2,
        VolumeX,
        X,
      } from 'https://esm.sh/lucide-preact@0.428.0?deps=preact@10.19.2';
      import htm from 'https://esm.sh/htm@3.1.1?deps=preact@10.19.2';

      const html = htm.bind(h);

      const STATUS_LABELS = {
        connecting: {
          label: 'Connexion…',
          ring: 'bg-amber-400/20 text-amber-200 border-amber-400/50',
          dot: 'bg-amber-300',
        },
        connected: {
          label: '',
          srLabel: 'Flux en cours',
          Icon: Activity,
          ring: 'bg-emerald-400/15 text-emerald-200 border-emerald-400/40',
          dot: 'bg-emerald-300',
        },
        reconnecting: {
          label: 'Reconnexion…',
          ring: 'bg-sky-400/15 text-sky-200 border-sky-400/40',
          dot: 'bg-sky-300',
        },
        error: {
          label: 'Hors ligne',
          ring: 'bg-rose-500/20 text-rose-100 border-rose-400/50',
          dot: 'bg-rose-300',
        },
      };

      const formatDuration = (ms) => {
        if (!ms || Number.isNaN(ms)) return '';
        const totalSeconds = Math.max(0, Math.round(ms / 1000));
        const minutes = Math.floor(totalSeconds / 60);
        const seconds = totalSeconds % 60;
        if (minutes === 0) return `${seconds}s`;
        if (minutes >= 60) {
          const hours = Math.floor(minutes / 60);
          const remMinutes = minutes % 60;
          return `${hours}h ${remMinutes}m`;
        }
        return `${minutes}m ${seconds.toString().padStart(2, '0')}s`;
      };

      const formatRelative = (timestamp, now) => {
        if (!timestamp) return '—';
        const diff = Math.max(0, now - timestamp);
        if (diff < 30_000) return 'il y a quelques secondes';
        if (diff < 5 * 60_000) return 'il y a moins de 5 min';
        return new Date(timestamp).toLocaleTimeString('fr-FR', {
          hour: '2-digit',
          minute: '2-digit',
        });
      };

      const normalizeAnonymousSlot = (raw) => {
        if (!raw || typeof raw !== 'object') {
          return {
            occupied: false,
            alias: null,
            claimedAt: null,
            expiresAt: null,
            remainingMs: null,
            connectionPending: false,
            message: null,
          };
        }

        return {
          occupied: Boolean(raw.occupied),
          alias: typeof raw.alias === 'string' ? raw.alias : null,
          claimedAt: Number.isFinite(raw.claimedAt) ? raw.claimedAt : null,
          expiresAt: Number.isFinite(raw.expiresAt) ? raw.expiresAt : null,
          remainingMs: Number.isFinite(raw.remainingMs) ? raw.remainingMs : null,
          connectionPending: Boolean(raw.connectionPending),
          message: typeof raw.message === 'string' ? raw.message : null,
        };
      };

      const StatusBadge = ({ status, className = '' }) => {
        const config = STATUS_LABELS[status] ?? STATUS_LABELS.connecting;
        const rawLabel = typeof config.label === 'string' ? config.label : '';
        const trimmedLabel = rawLabel.trim();
        const srText = config.srLabel ?? (trimmedLabel ? trimmedLabel : 'Statut');
        return html`
          <div
            class=${`flex items-center gap-2 rounded-full border px-4 py-2 text-sm font-medium backdrop-blur ${config.ring} ${className}`}
            aria-label=${srText}
          >
            <span class=${`h-2.5 w-2.5 rounded-full shadow-md ${config.dot}`}></span>
            <span class="flex items-center gap-1">
              ${config.Icon ? html`<${config.Icon} class="h-4 w-4" aria-hidden="true" />` : null}
              <span class="sr-only">${srText}</span>
              ${trimmedLabel
                ? html`<span aria-hidden="true">${rawLabel}</span>`
                : null}
            </span>
          </div>
        `;
      };

      const useSmoothReorder = (ids) => {
        const containerRef = useRef(null);
        const positionsRef = useRef(new Map());

        useLayoutEffect(() => {
          if (typeof window === 'undefined') return;
          const container = containerRef.current;
          if (!container) return;

          const prefersReducedMotion = window.matchMedia?.('(prefers-reduced-motion: reduce)')?.matches;
          const elements = Array.from(container.querySelectorAll('[data-speaker-id]'));
          const nextPositions = new Map();

          for (const element of elements) {
            const id = element.getAttribute('data-speaker-id');
            if (!id) continue;
            nextPositions.set(id, element.getBoundingClientRect());
          }

          if (!prefersReducedMotion) {
            for (const element of elements) {
              const id = element.getAttribute('data-speaker-id');
              if (!id) continue;
              const previous = positionsRef.current.get(id);
              const current = nextPositions.get(id);
              if (!previous || !current) continue;
              const deltaX = previous.left - current.left;
              const deltaY = previous.top - current.top;
              if ((deltaX === 0 && deltaY === 0) || typeof element.animate !== 'function') continue;
              element.animate(
                [
                  { transform: `translate(${deltaX}px, ${deltaY}px)` },
                  { transform: 'translate(0, 0)' },
                ],
                {
                  duration: 1600,
                  easing: 'cubic-bezier(0.16, 1, 0.3, 1)',
                },
              );
            }
          }

          positionsRef.current = nextPositions;
        }, [ids.join('|')]);

        return containerRef;
      };

      const SpeakerCard = ({ speaker, now, cardId }) => {
        const voiceState = speaker.voiceState ?? {};
        const isSpeaking = Boolean(speaker.isSpeaking);
        const duration = isSpeaking && speaker.startedAt ? formatDuration(now - speaker.startedAt) : null;
        const lastSpoke = !isSpeaking && speaker.lastSpokeAt ? formatRelative(speaker.lastSpokeAt, now) : null;

        const cardState = isSpeaking ? 'speaking' : 'idle';
        const cardAccentClass = isSpeaking
          ? 'border-fuchsia-400/60 bg-gradient-to-br from-indigo-500/20 via-slate-950 to-fuchsia-500/15'
          : 'border-white/10 bg-slate-950/75';

        const badgeConfig = (() => {
          if (isSpeaking) {
            return {
              srLabel: 'Intervention en cours',
              label: '',
              Icon: Activity,
              classes: 'bg-emerald-500 text-emerald-900',
              ping: true,
              dot: 'bg-emerald-800',
            };
          }
          if (voiceState.selfMute || voiceState.mute) {
            return {
              srLabel: 'Micro coupé',
              label: 'Muet',
              Icon: MicOff,
              classes: 'bg-slate-200/90 text-slate-900',
              ping: false,
              dot: 'bg-slate-900/70',
            };
          }
          if (voiceState.selfDeaf || voiceState.deaf) {
            return {
              srLabel: 'Casque coupé',
              label: 'Casque',
              Icon: Headphones,
              classes: 'bg-slate-200/90 text-slate-900',
              ping: false,
              dot: 'bg-slate-900/70',
            };
          }
          return {
            srLabel: 'À l’écoute',
            label: 'Écoute',
            Icon: Headphones,
            classes: 'bg-slate-200/90 text-slate-900',
            ping: false,
            dot: 'bg-slate-900/70',
          };
        })();

        const secondaryInfo = (() => {
          if (isSpeaking) {
            return {
              Icon: Activity,
              text: duration ? `Depuis ${duration}` : null,
              srLabel: duration
                ? `Intervention en cours depuis ${duration}`
                : 'Intervention en cours',
            };
          }
          if (lastSpoke) {
            return {
              Icon: Clock3,
              text: lastSpoke,
              srLabel: `Dernière intervention ${lastSpoke}`,
            };
          }
          return {
            Icon: Clock3,
            text: 'Pas encore intervenu',
            srLabel: 'Pas encore intervenu',
          };
        })();

        const { Icon: SecondaryIcon, text: secondaryText, srLabel: secondarySrLabel } = secondaryInfo;

        const voiceBadges = [];
        if (voiceState.selfMute || voiceState.mute) {
          voiceBadges.push({ key: 'mute', label: 'Muet', Icon: MicOff });
        }
        if (voiceState.selfDeaf || voiceState.deaf) {
          voiceBadges.push({ key: 'deaf', label: 'Casque off', Icon: Headphones });
        }
        if (voiceState.streaming) {
          voiceBadges.push({ key: 'stream', label: 'Partage', Icon: MonitorPlay });
        }
        if (voiceState.video) {
          voiceBadges.push({ key: 'video', label: 'Caméra', Icon: Video });
        }

        return html`
          <article
            class=${`speaker-card group relative overflow-hidden rounded-3xl border ${cardAccentClass} p-5 shadow-xl shadow-indigo-900/30 transition duration-300 hover:border-fuchsia-400/60 hover:shadow-glow`}
            data-state=${cardState}
            data-speaker-id=${cardId ?? speaker.id}
          >
            <div class="absolute -right-14 -top-14 h-32 w-32 rounded-full bg-fuchsia-500/40 blur-3xl transition-opacity duration-300 group-hover:opacity-100"></div>
            <div class="relative flex items-center gap-5">
              <div class="relative h-20 w-20 flex-shrink-0">
                <div class="absolute inset-0 rounded-full bg-gradient-to-br from-fuchsia-500 via-indigo-400 to-sky-400 opacity-60 blur-xl transition group-hover:opacity-90"></div>
                <img
                  src=${speaker.avatar}
                  alt=${`Avatar de ${speaker.displayName}`}
                  class="relative h-20 w-20 rounded-full border-2 border-white/70 object-cover shadow-lg shadow-fuchsia-900/30"
                  loading="lazy"
                />
                <div
                  class=${`absolute -bottom-1 -right-1 flex items-center gap-1 rounded-full px-2 py-0.5 text-[0.6rem] font-semibold uppercase tracking-wider shadow-lg ${badgeConfig.classes}`}
                >
                  <span class="relative flex h-2 w-2">
                    <span
                      class=${`absolute inline-flex h-full w-full rounded-full ${
                        badgeConfig.ping ? 'animate-ping bg-emerald-200 opacity-75' : 'bg-slate-400/70 opacity-0'
                      }`}
                    ></span>
                    <span class=${`relative inline-flex h-2 w-2 rounded-full ${badgeConfig.dot}`}></span>
                  </span>
                  <span class="sr-only">${badgeConfig.srLabel}</span>
                  <${badgeConfig.Icon} class="h-3.5 w-3.5" aria-hidden="true" />
                  ${badgeConfig.label && badgeConfig.label.trim()
                    ? html`<span aria-hidden="true">${badgeConfig.label}</span>`
                    : null}
                </div>
              </div>
              <div class="relative flex flex-1 flex-col gap-2">
                <div class="flex flex-wrap items-baseline gap-2">
                  <h3 class="text-2xl font-semibold text-white">${speaker.displayName}</h3>
                  <span class="text-sm text-slate-300">@${speaker.username}</span>
                </div>
                <div class="flex flex-wrap items-center gap-3 text-xs text-slate-200">
                  <span class="flex items-center gap-1 rounded-full bg-white/10 px-3 py-1 backdrop-blur">
                    <${SecondaryIcon} class="h-3.5 w-3.5" aria-hidden="true" />
                    ${secondaryText ? html`<span>${secondaryText}</span>` : null}
                    <span class="sr-only">${secondarySrLabel}</span>
                  </span>
                </div>
                ${voiceBadges.length
                  ? html`<div class="flex flex-wrap items-center gap-2 text-slate-200/80">
                      ${voiceBadges.map(
                        ({ key, label, Icon }) => html`<span
                          key=${key}
                          class="inline-flex items-center gap-1 rounded-full bg-white/10 px-2.5 py-1 text-[0.65rem] font-medium uppercase tracking-[0.2em] text-slate-100 backdrop-blur transition hover:bg-white/15"
                          title=${label}
                          aria-label=${label}
                        >
                          <${Icon} class="h-3.5 w-3.5" aria-hidden="true" />
                          <span aria-hidden="true">${label}</span>
                        </span>`,
                      )}
                    </div>`
                  : null}
              </div>
            </div>
          </article>
        `;
      };
      const SpeakersSection = ({ speakers, now }) => {
        const speakerIds = useMemo(() => speakers.map((speaker) => String(speaker.id ?? '')), [speakers]);
        const containerRef = useSmoothReorder(speakerIds);

        if (!speakers.length) {
          return html`
            <div class="mt-6 flex flex-col items-center justify-center gap-4 rounded-3xl border border-white/10 bg-black/40 px-8 py-12 text-center text-sm text-slate-300 backdrop-blur">
              <div class="flex h-14 w-14 items-center justify-center rounded-full bg-white/10 text-fuchsia-200">
                <${Users} class="h-7 w-7" aria-hidden="true" />
              </div>
              <p class="max-w-sm text-base text-slate-300">
                Aucun participant n'est connecté au salon vocal pour le moment. Dès qu’une personne rejoindra, elle apparaîtra ici.
              </p>
            </div>
          `;
        }

        return html`
          <div ref=${containerRef} class="mt-6 grid gap-6 sm:grid-cols-2">
            ${speakers.map((speaker) => html`<${SpeakerCard} key=${speaker.id} speaker=${speaker} now=${now} cardId=${speaker.id} />`)}
          </div>
        `;
      };

      const AnonymousBooth = ({ slot, now }) => {
        const [session, setSession] = useState(() => ({
          token: null,
          alias: null,
          expiresAt: null,
          stage: 'idle',
          error: null,
          info: null,
          micGranted: false,
          wsConnected: false,
          level: 0,
        }));

        const tokenRef = useRef(null);
        const mediaStreamRef = useRef(null);
        const processorRef = useRef(null);
        const audioContextRef = useRef(null);
        const wsRef = useRef(null);
        const levelLastUpdateRef = useRef(0);
        const mountedRef = useRef(true);

        const ensurePrimaryStreamPlayback = useCallback(async () => {
          const audio = document.querySelector('audio[data-role="primary-stream"]');
          if (!audio) {
            return;
          }

          try {
            audio.muted = false;
            if (audio.paused) {
              await audio.play();
            }
          } catch (error) {
            console.warn('Impossible de maintenir la lecture du flux principal', error);
          }
        }, []);

        const stopAudioProcessing = useCallback(async () => {
          if (processorRef.current) {
            try {
              processorRef.current.disconnect();
            } catch (error) {
              console.warn('Impossible de déconnecter le processeur audio', error);
            }
            processorRef.current.onaudioprocess = null;
            processorRef.current = null;
          }

          if (mediaStreamRef.current) {
            try {
              for (const track of mediaStreamRef.current.getTracks()) {
                track.stop();
              }
            } catch (error) {
              console.warn('Impossible de stopper la capture micro', error);
            }
            mediaStreamRef.current = null;
          }

          if (audioContextRef.current) {
            try {
              await audioContextRef.current.close();
            } catch (error) {
              console.warn("Impossible de fermer l'AudioContext", error);
            }
            audioContextRef.current = null;
          }

          if (mountedRef.current) {
            setSession((prev) => ({ ...prev, micGranted: false, level: 0 }));
          }
        }, []);

        const cleanup = useCallback(
          async ({ notifyServer = false, reason = null } = {}) => {
            const socket = wsRef.current;
            if (socket) {
              wsRef.current = null;
              try {
                socket.onopen = null;
                socket.onclose = null;
                socket.onmessage = null;
                socket.onerror = null;
                socket.close();
              } catch (error) {
                console.warn('Impossible de fermer la connexion WebSocket anonyme', error);
              }
            }

            await stopAudioProcessing();
            await ensurePrimaryStreamPlayback();

            const tokenValue = tokenRef.current;
            tokenRef.current = null;

            if (notifyServer && tokenValue) {
              try {
                await fetch('/anonymous-slot', {
                  method: 'DELETE',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ token: tokenValue }),
                });
              } catch (error) {
                console.warn('Impossible de libérer le micro anonyme', error);
              }
            }

            if (mountedRef.current) {
              setSession((prev) => ({
                ...prev,
                token: null,
                alias: null,
                expiresAt: null,
                stage: 'idle',
                wsConnected: false,
                micGranted: false,
                level: 0,
                info: reason ?? prev.info,
                error: null,
              }));
            }
          },
          [stopAudioProcessing, ensurePrimaryStreamPlayback],
        );

        useEffect(() => () => {
          mountedRef.current = false;
          cleanup({ notifyServer: Boolean(tokenRef.current), reason: 'Micro libéré.' });
        }, [cleanup]);

        useEffect(() => {
          tokenRef.current = session.token;
        }, [session.token]);

        useEffect(() => {
          if (!session.token) {
            return;
          }

          if (!slot?.occupied) {
            cleanup({ notifyServer: false, reason: 'Micro libéré automatiquement.' });
            return;
          }

          if (slot.alias && session.alias && slot.alias !== session.alias) {
            cleanup({ notifyServer: false, reason: "Le micro est désormais occupé par quelqu'un d'autre." });
          }
        }, [slot?.occupied, slot?.alias, session.token, session.alias, cleanup]);

        useEffect(() => {
          if (!session.token || !session.alias) {
            return;
          }
          if (!slot?.alias || slot.alias !== session.alias) {
            return;
          }
          if (slot.expiresAt && slot.expiresAt !== session.expiresAt) {
            setSession((prev) => ({ ...prev, expiresAt: slot.expiresAt }));
          }
        }, [slot?.expiresAt, slot?.alias, session.alias, session.token, session.expiresAt]);

        const prepareMicrophone = useCallback(async () => {
          if (!navigator?.mediaDevices?.getUserMedia) {
            throw new Error("Ton navigateur ne supporte pas l'enregistrement audio.");
          }

          let stream;
          try {
            stream = await navigator.mediaDevices.getUserMedia({
              audio: {
                channelCount: 1,
                sampleRate: 48000,
                noiseSuppression: true,
                echoCancellation: true,
                autoGainControl: true,
              },
            });
          } catch (error) {
            throw new Error('Accès au micro refusé. Autorise ton micro pour intervenir.');
          }

          mediaStreamRef.current = stream;

          const AudioContextClass = window.AudioContext || window.webkitAudioContext;
          if (!AudioContextClass) {
            throw new Error('AudioContext indisponible sur ce navigateur.');
          }

          const audioContext = new AudioContextClass({ sampleRate: 48000 });
          audioContextRef.current = audioContext;
          if (audioContext.state === 'suspended') {
            try {
              await audioContext.resume();
            } catch (error) {
              console.warn("Impossible de reprendre l'AudioContext", error);
            }
          }

          await ensurePrimaryStreamPlayback();

          const source = audioContext.createMediaStreamSource(stream);
          const processor = audioContext.createScriptProcessor(1024, 1, 1);
          const gain = audioContext.createGain();
          gain.gain.value = 0;
          processor.connect(gain);
          gain.connect(audioContext.destination);
          source.connect(processor);
          processorRef.current = processor;

          processor.onaudioprocess = (event) => {
            const input = event.inputBuffer?.getChannelData?.(0);
            const output = event.outputBuffer?.getChannelData?.(0);
            if (!input) {
              return;
            }

            if (output) {
              for (let i = 0; i < output.length; i++) {
                output[i] = 0;
              }
            }

            const frameLength = input.length;
            const buffer = new ArrayBuffer(frameLength * 4);
            const view = new DataView(buffer);
            let sumSquares = 0;
            for (let i = 0; i < frameLength; i++) {
              const sample = input[i];
              sumSquares += sample * sample;
              const clamped = Math.max(-1, Math.min(1, sample));
              const intSample = clamped < 0 ? clamped * 0x8000 : clamped * 0x7fff;
              view.setInt16(i * 4, intSample, true);
              view.setInt16(i * 4 + 2, intSample, true);
            }

            const socket = wsRef.current;
            if (socket && socket.readyState === WebSocket.OPEN) {
              try {
                socket.send(buffer);
              } catch (error) {
                console.warn("Impossible d'envoyer un chunk audio anonyme", error);
              }
            }

            const level = frameLength > 0 ? Math.sqrt(sumSquares / frameLength) : 0;
            const nowPerf = typeof performance !== 'undefined' && performance.now ? performance.now() : Date.now();
            if (nowPerf - levelLastUpdateRef.current > 120) {
              levelLastUpdateRef.current = nowPerf;
              if (mountedRef.current) {
                setSession((prev) => ({ ...prev, level }));
              }
            }
          };

          if (mountedRef.current) {
            setSession((prev) => ({ ...prev, micGranted: true }));
          }
        }, [ensurePrimaryStreamPlayback]);

        const connectWebSocket = useCallback(() => {
          const tokenValue = tokenRef.current;
          if (!tokenValue) {
            if (mountedRef.current) {
              setSession((prev) => ({ ...prev, stage: 'idle', error: 'Session anonyme introuvable.', info: null }));
            }
            return;
          }

          const protocol = window.location.protocol === 'https:' ? 'wss' : 'ws';
          const socket = new WebSocket(
            `${protocol}://${window.location.host}/anonymous-stream?token=${encodeURIComponent(tokenValue)}`,
          );
          socket.binaryType = 'arraybuffer';
          wsRef.current = socket;

          socket.onopen = () => {
            if (!mountedRef.current) {
              return;
            }
            ensurePrimaryStreamPlayback().catch((error) => {
              console.warn('Impossible de reprendre le flux principal après connexion WS', error);
            });
            setSession((prev) => ({
              ...prev,
              stage: 'streaming',
              wsConnected: true,
              info: 'Tu es en direct. Reste cool et anonyme.',
              error: null,
            }));
          };

          socket.onmessage = (event) => {
            if (typeof event.data !== 'string') {
              return;
            }
            try {
              const payload = JSON.parse(event.data);
              if (payload?.type === 'terminated') {
                cleanup({ notifyServer: false, reason: payload.message || 'Session terminée.' });
              }
            } catch (error) {
              console.warn('Message WebSocket anonyme invalide', error);
            }
          };

          socket.onerror = (event) => {
            console.warn('Erreur WebSocket anonyme', event);
            if (mountedRef.current) {
              setSession((prev) => ({ ...prev, error: 'Connexion instable avec le bot.', wsConnected: false }));
            }
          };

          socket.onclose = (event) => {
            if (wsRef.current === socket) {
              wsRef.current = null;
            }
            stopAudioProcessing();
            ensurePrimaryStreamPlayback().catch((error) => {
              console.warn('Impossible de reprendre le flux principal après fermeture du micro', error);
            });
            tokenRef.current = null;
            if (mountedRef.current) {
              setSession((prev) => ({
                ...prev,
                token: null,
                alias: null,
                expiresAt: null,
                stage: 'idle',
                wsConnected: false,
                micGranted: false,
                level: 0,
                info: event?.reason || 'Connexion au micro fermée.',
              }));
            }
          };
        }, [cleanup, stopAudioProcessing, ensurePrimaryStreamPlayback]);

        const handleClaim = async () => {
          if (session.stage !== 'idle') {
            return;
          }

          if (mountedRef.current) {
            setSession((prev) => ({
              ...prev,
              stage: 'claiming',
              error: null,
              info: 'Réservation du micro en cours…',
            }));
          }

          let payload = {};
          try {
            const response = await fetch('/anonymous-slot', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
            });
            payload = await response.json().catch(() => ({}));
            if (!response.ok) {
              throw new Error(payload?.message || 'Le micro est déjà pris. Réessaie dans un instant.');
            }
          } catch (error) {
            const message = error instanceof Error ? error.message : 'Impossible de réserver le micro anonyme.';
            if (mountedRef.current) {
              setSession((prev) => ({ ...prev, stage: 'idle', error: message, info: null }));
            }
            return;
          }

          tokenRef.current = payload?.token || null;
          if (!tokenRef.current) {
            if (mountedRef.current) {
              setSession((prev) => ({ ...prev, stage: 'idle', error: 'Réponse du serveur invalide.', info: null }));
            }
            return;
          }

          if (mountedRef.current) {
            setSession((prev) => ({
              ...prev,
              token: payload.token,
              alias: payload.alias || 'Anonyme',
              expiresAt: payload.expiresAt || null,
              stage: 'preparing',
              error: null,
              info: 'Activation du micro en cours…',
            }));
          }

          try {
            await prepareMicrophone();
          } catch (error) {
            const message = error instanceof Error ? error.message : "Impossible d'initialiser ton micro.";
            await cleanup({ notifyServer: true, reason: message });
            if (mountedRef.current) {
              setSession((prev) => ({ ...prev, error: message, stage: 'idle', info: null }));
            }
            return;
          }

          if (mountedRef.current) {
            setSession((prev) => ({ ...prev, stage: 'connecting', info: 'Connexion au bot…' }));
          }

          connectWebSocket();
        };

        const handleRelease = () => {
          cleanup({ notifyServer: true, reason: 'Micro libéré.' });
        };

        const isOwner = Boolean(session.token && session.alias && slot?.alias === session.alias);
        const slotTaken = Boolean(slot?.occupied && (!session.alias || slot.alias !== session.alias));
        const stage = session.stage;
        const isBusy = stage === 'claiming';
        const canCancel = stage === 'preparing' || stage === 'connecting';
        const expiresAt = isOwner ? session.expiresAt ?? slot?.expiresAt ?? null : slot?.expiresAt ?? null;
        const timeRemainingMs = expiresAt ? Math.max(0, expiresAt - now) : slot?.remainingMs ?? null;
        const timeRemainingLabel = timeRemainingMs ? formatDuration(timeRemainingMs) : null;
        const levelPercent = Math.min(100, Math.round(Math.min(1, session.level) * 100));

        return html`
          <section class="relative overflow-hidden rounded-3xl border border-white/10 bg-white/5 p-8 backdrop-blur-xl">
            <div class="pointer-events-none absolute -left-24 top-[-10rem] h-64 w-64 rounded-full bg-indigo-500/20 blur-3xl"></div>
            <div class="pointer-events-none absolute -right-24 bottom-[-8rem] h-72 w-72 rounded-full bg-fuchsia-500/20 blur-[120px]"></div>
            <div class="relative flex flex-col gap-6 lg:flex-row lg:items-start lg:justify-between">
              <div class="flex-1 space-y-4">
                <div class="flex flex-wrap items-center gap-3 text-[0.65rem] uppercase tracking-[0.35em] text-indigo-200">
                  <span class="inline-flex items-center gap-2 rounded-full border border-indigo-400/40 bg-indigo-500/20 px-3 py-1 text-indigo-100">
                    <${Mic} class="h-3.5 w-3.5" aria-hidden="true" />
                    Micro anonyme
                  </span>
                  <span class="inline-flex items-center gap-1 text-[0.6rem] text-slate-300">
                    <${ShieldCheck} class="h-3 w-3" aria-hidden="true" />
                    <span>Identité masquée</span>
                  </span>
                </div>
                <h2 class="text-2xl font-semibold text-white sm:text-3xl">Micro anonyme instantané</h2>
                <p class="text-sm text-slate-300">
                  Réserve le slot, parle via le bot et reste totalement anonyme. Un seul micro secret à la fois.
                </p>

                ${slotTaken
                  ? html`<div class="flex flex-col gap-2 rounded-2xl border border-white/10 bg-white/5 px-4 py-3 text-sm text-slate-200">
                      <div class="flex items-center gap-2 text-slate-100">
                        <${Activity} class="h-4 w-4 text-fuchsia-200" aria-hidden="true" />
                        <span>${slot.alias ?? 'Anonyme'} est en direct</span>
                      </div>
                      <div class="flex items-center gap-2 text-[0.75rem] text-slate-300">
                        <${Clock3} class="h-3.5 w-3.5" aria-hidden="true" />
                        <span>${timeRemainingLabel ? `Temps restant estimé : ${timeRemainingLabel}` : 'Temps restant : —'}</span>
                      </div>
                      ${slot.connectionPending
                        ? html`<p class="text-xs text-slate-300/80">
                            La connexion est en cours, le micro sera actif d’ici quelques secondes.
                          </p>`
                        : null}
                    </div>`
                  : null}

                ${session.info
                  ? html`<div class="rounded-2xl border border-indigo-400/30 bg-indigo-500/10 px-4 py-3 text-sm text-indigo-100">
                      ${session.info}
                    </div>`
                  : null}

                ${session.error
                  ? html`<div class="flex items-center gap-2 rounded-2xl border border-rose-500/40 bg-rose-500/10 px-4 py-3 text-sm text-rose-100">
                      <${AlertCircle} class="h-4 w-4" aria-hidden="true" />
                      <span>${session.error}</span>
                    </div>`
                  : null}
              </div>

              <div class="w-full max-w-md rounded-2xl border border-white/10 bg-black/45 p-5 shadow-xl shadow-slate-950/30 backdrop-blur">
                ${isOwner
                  ? html`<div class="flex items-center justify-between rounded-xl border border-emerald-400/40 bg-emerald-500/10 px-4 py-3 text-sm text-emerald-100">
                      <span class="flex items-center gap-2">
                        <${ShieldCheck} class="h-4 w-4" aria-hidden="true" />
                        <span>Alias secret</span>
                      </span>
                      <span class="font-semibold text-emerald-200">${session.alias}</span>
                    </div>`
                  : null}

                ${isOwner && timeRemainingLabel
                  ? html`<div class="mt-3 flex items-center justify-between rounded-xl border border-fuchsia-400/40 bg-fuchsia-500/10 px-4 py-2 text-xs uppercase tracking-[0.3em] text-fuchsia-100">
                      <span class="flex items-center gap-2">
                        <${Clock3} class="h-3.5 w-3.5" aria-hidden="true" />
                        Chrono
                      </span>
                      <span class="text-sm tracking-normal">${timeRemainingLabel}</span>
                    </div>`
                  : null}

                ${isOwner
                  ? html`<div class="mt-4 space-y-4">
                      <div>
                        <p class="text-xs font-semibold uppercase tracking-[0.35em] text-slate-300">Niveau du micro</p>
                        <div class="mt-2 mic-meter">
                          <div class="mic-meter-bar" style=${{ width: `${levelPercent}%` }}></div>
                        </div>
                      </div>
                      <button
                        type="button"
                        class="flex w-full items-center justify-center gap-2 rounded-full border border-rose-400/40 bg-rose-500/20 px-5 py-2.5 text-sm font-semibold text-rose-100 transition hover:bg-rose-500/30 hover:text-white focus:outline-none focus:ring-2 focus:ring-rose-300 focus:ring-offset-2 focus:ring-offset-slate-950"
                        onClick=${handleRelease}
                      >
                        Raccrocher
                      </button>
                    </div>`
                  : isBusy
                  ? html`<div class="flex flex-col gap-3">
                      <button
                        type="button"
                        class="flex w-full items-center justify-center gap-2 rounded-full border border-white/10 bg-white/10 px-5 py-2.5 text-sm font-semibold text-slate-200"
                        disabled
                      >
                        <span class="h-4 w-4 animate-spin rounded-full border-2 border-slate-200 border-t-transparent"></span>
                        Réservation en cours…
                      </button>
                    </div>`
                  : canCancel
                  ? html`<div class="flex flex-col gap-3">
                      <button
                        type="button"
                        class="flex w-full items-center justify-center gap-2 rounded-full border border-white/10 bg-white/10 px-5 py-2.5 text-sm font-semibold text-slate-200"
                        disabled
                      >
                        <span class="h-4 w-4 animate-spin rounded-full border-2 border-slate-200 border-t-transparent"></span>
                        Connexion au bot…
                      </button>
                      <button
                        type="button"
                        class="flex w-full items-center justify-center gap-2 rounded-full border border-white/10 bg-slate-900/70 px-5 py-2.5 text-sm font-semibold text-slate-200 transition hover:bg-slate-900 focus:outline-none focus:ring-2 focus:ring-slate-300 focus:ring-offset-2 focus:ring-offset-slate-950"
                        onClick=${() => cleanup({ notifyServer: true, reason: 'Connexion annulée.' })}
                      >
                        Annuler
                      </button>
                    </div>`
                  : html`<div class="flex flex-col gap-3">
                      <button
                        type="button"
                        class="flex w-full items-center justify-center gap-2 rounded-full border border-fuchsia-400/60 bg-fuchsia-500/20 px-5 py-2.5 text-sm font-semibold text-fuchsia-100 shadow-lg shadow-fuchsia-900/40 transition hover:bg-fuchsia-500/30 hover:text-white focus:outline-none focus:ring-2 focus:ring-fuchsia-300 focus:ring-offset-2 focus:ring-offset-slate-950 disabled:cursor-not-allowed disabled:opacity-40"
                        onClick=${handleClaim}
                        disabled=${slotTaken}
                      >
                        ${slotTaken ? 'Micro occupé' : 'Prendre la parole anonymement'}
                        ${!slotTaken ? html`<${Mic} class="h-4 w-4" aria-hidden="true" />` : null}
                      </button>
                      <p class="text-xs text-slate-400">
                        ${slotTaken
                          ? 'Attends la fin du passage actuel pour réserver à ton tour.'
                          : 'Ton intervention est routée via le bot : aucune trace, aucun pseudo.'}
                      </p>
                    </div>`}
              </div>
            </div>
          </section>
        `;
      };

      const NAV_LINKS = [
        { label: 'Accueil', route: 'home', hash: '#/' },
        { label: 'À propos', route: 'about', hash: '#/about' },
      ];

      const getRouteFromHash = () => {
        const hash = window.location.hash.replace(/^#/, '').toLowerCase();
        if (hash === '/about' || hash === 'about') {
          return 'about';
        }
        return 'home';
      };

      const AudioPlayer = ({ streamInfo, audioKey, status }) => {
        const audioRef = useRef(null);
        const [isPlaying, setIsPlaying] = useState(false);
        const [isLoading, setIsLoading] = useState(true);
        const [hasError, setHasError] = useState(false);
        const [isMuted, setIsMuted] = useState(false);
        const [volume, setVolume] = useState(0.75);
        const lastVolumeRef = useRef(0.75);

        const isIgnorablePlayError = (error) => {
          if (!error) return false;
          const name = error.name || '';
          return name === 'AbortError' || name === 'NotAllowedError';
        };

        useEffect(() => {
          const audio = audioRef.current;
          if (!audio) return undefined;

          const handlePlaying = () => {
            setIsPlaying(true);
            setIsLoading(false);
            setHasError(false);
          };

          const handleWaiting = () => {
            if (!audio.paused) {
              setIsLoading(true);
            }
          };

          const handlePause = () => {
            setIsPlaying(false);
            setIsLoading(false);
          };

          const handleCanPlay = () => {
            setIsLoading(false);
          };

          const handleError = () => {
            setHasError(true);
            setIsPlaying(false);
            setIsLoading(false);
          };

          const handleEnded = () => {
            setIsPlaying(false);
          };

          audio.addEventListener('playing', handlePlaying);
          audio.addEventListener('waiting', handleWaiting);
          audio.addEventListener('pause', handlePause);
          audio.addEventListener('canplay', handleCanPlay);
          audio.addEventListener('canplaythrough', handleCanPlay);
          audio.addEventListener('stalled', handleWaiting);
          audio.addEventListener('suspend', handleWaiting);
          audio.addEventListener('error', handleError);
          audio.addEventListener('ended', handleEnded);

          return () => {
            audio.removeEventListener('playing', handlePlaying);
            audio.removeEventListener('waiting', handleWaiting);
            audio.removeEventListener('pause', handlePause);
            audio.removeEventListener('canplay', handleCanPlay);
            audio.removeEventListener('canplaythrough', handleCanPlay);
            audio.removeEventListener('stalled', handleWaiting);
            audio.removeEventListener('suspend', handleWaiting);
            audio.removeEventListener('error', handleError);
            audio.removeEventListener('ended', handleEnded);
          };
        }, []);

        useEffect(() => {
          const audio = audioRef.current;
          if (!audio) return;
          audio.volume = Math.min(1, Math.max(0, volume));
        }, [volume]);

        useEffect(() => {
          const audio = audioRef.current;
          if (!audio) return;
          audio.muted = isMuted;
        }, [isMuted]);

        useEffect(() => {
          const audio = audioRef.current;
          if (!audio) return;

          setHasError(false);

          if (!audio.paused) {
            audio.pause();
          }
          audio.src = streamInfo.path;
          audio.load();
          setIsLoading(true);

          const attemptPlay = async () => {
            try {
              await audio.play();
            } catch (error) {
              console.warn('Lecture automatique bloquée', error);
              setIsLoading(false);
            }
          };

          attemptPlay();

          return () => {
            audio.pause();
          };
        }, [audioKey, streamInfo.path]);

        const clearBrowserCaches = async () => {
          if (typeof window === 'undefined') {
            return;
          }

          if ('caches' in window) {
            try {
              const cacheNames = await caches.keys();
              await Promise.all(
                cacheNames.map((cacheName) =>
                  caches.delete(cacheName).catch((error) => {
                    console.warn(`Impossible de supprimer le cache ${cacheName}`, error);
                    return false;
                  }),
                ),
              );
            } catch (error) {
              console.warn('Impossible de vider les caches du navigateur', error);
            }
          }

          if ('serviceWorker' in navigator) {
            try {
              const registrations = await navigator.serviceWorker.getRegistrations();
              await Promise.all(
                registrations.map((registration) =>
                  registration.unregister().catch((error) => {
                    console.warn('Impossible de désinscrire un service worker', error);
                    return false;
                  }),
                ),
              );
            } catch (error) {
              console.warn('Impossible de récupérer les service workers', error);
            }
          }
        };

        const togglePlay = async () => {
          const audio = audioRef.current;
          if (!audio) return;

          if (hasError) {
            setHasError(false);
          }

          if (isPlaying) {
            audio.pause();
            return;
          }

          setIsLoading(true);

          try {
            await clearBrowserCaches();
          } catch (error) {
            console.warn('Impossible de vider le cache du navigateur avant la lecture', error);
          }

          try {
            audio.currentTime = 0;
            audio.load();
          } catch (error) {
            console.warn('Impossible de recharger la source audio', error);
          }

          try {
            await audio.play();
          } catch (error) {
            if (isIgnorablePlayError(error)) {
              setIsLoading(false);
              return;
            }
            console.error('Impossible de lancer la lecture', error);
            setHasError(true);
            setIsLoading(false);
          }
        };

        const handleRetry = async () => {
          const audio = audioRef.current;
          if (!audio) return;

          setHasError(false);
          setIsLoading(true);

          try {
            await clearBrowserCaches();
          } catch (error) {
            console.warn('Impossible de vider le cache du navigateur avant la relance', error);
          }

          if (!audio.paused) {
            audio.pause();
          }
          audio.src = streamInfo.path;

          try {
            audio.currentTime = 0;
            audio.load();
          } catch (error) {
            console.warn('Impossible de recharger la source audio avant la relance', error);
          }

          try {
            await audio.play();
          } catch (error) {
            if (isIgnorablePlayError(error)) {
              setIsLoading(false);
              return;
            }
            console.error('La relance du flux a échoué', error);
            setHasError(true);
            setIsLoading(false);
          }
        };

        const handleVolumeChange = (event) => {
          const value = Number(event?.target?.value ?? 0) / 100;
          const nextVolume = Number.isFinite(value) ? Math.min(1, Math.max(0, value)) : 0;
          setVolume(nextVolume);
          if (nextVolume === 0) {
            setIsMuted(true);
          } else {
            lastVolumeRef.current = nextVolume;
            if (isMuted) {
              setIsMuted(false);
            }
          }
        };

        const toggleMute = () => {
          if (isMuted || volume === 0) {
            const restored = lastVolumeRef.current > 0 ? lastVolumeRef.current : 0.5;
            setVolume(restored);
            setIsMuted(false);
          } else {
            lastVolumeRef.current = volume > 0 ? volume : lastVolumeRef.current;
            setIsMuted(true);
          }
        };

        const renderVolumeIcon = () => {
          if (hasError) {
            return html`<${AlertCircle} class="h-5 w-5" aria-hidden="true" />`;
          }

          if (isMuted || volume === 0) {
            return html`<${VolumeX} class="h-5 w-5" aria-hidden="true" />`;
          }

          if (volume < 0.4) {
            return html`<${Volume} class="h-5 w-5" aria-hidden="true" />`;
          }

          if (volume < 0.75) {
            return html`<${Volume1} class="h-5 w-5" aria-hidden="true" />`;
          }

          return html`<${Volume2} class="h-5 w-5" aria-hidden="true" />`;
        };

        const statusConfig = STATUS_LABELS[status] ?? STATUS_LABELS.connecting;
        const statusText = hasError
          ? 'Flux indisponible. Relance le flux pour réessayer.'
          : isLoading
          ? 'Connexion au flux…'
          : isPlaying
          ? 'Lecture en cours'
          : 'En pause';

        return html`
          <div class="relative mt-6 overflow-hidden rounded-2xl border border-white/10 bg-slate-950/80 p-6 shadow-2xl shadow-slate-950/60 backdrop-blur">
            <div class="pointer-events-none absolute -left-32 top-[-8rem] h-72 w-72 rounded-full bg-fuchsia-500/25 blur-3xl"></div>
            <div class="pointer-events-none absolute -right-36 bottom-[-10rem] h-80 w-80 rounded-full bg-indigo-500/25 blur-[110px]"></div>
            <div class="relative flex flex-col gap-6 xl:flex-row xl:items-center xl:justify-between">
              <div class="flex flex-1 flex-col gap-4 sm:flex-row sm:items-center">
                <div class="flex items-center gap-5">
                  <button
                    type="button"
                    class="relative flex h-24 w-24 shrink-0 items-center justify-center overflow-hidden rounded-full bg-gradient-to-br from-fuchsia-500 via-indigo-500 to-sky-400 text-white shadow-lg shadow-fuchsia-900/40 transition focus:outline-none focus:ring-2 focus:ring-fuchsia-300 focus:ring-offset-2 focus:ring-offset-slate-950 hover:scale-105 disabled:cursor-not-allowed disabled:opacity-60"
                    aria-label=${isPlaying ? 'Mettre le flux en pause' : 'Lancer la lecture du flux'}
                    onClick=${togglePlay}
                    disabled=${isLoading && !isPlaying && !hasError}
                  >
                    ${
                      hasError
                        ? html`<${AlertCircle} class="h-7 w-7" aria-hidden="true" />`
                        : isLoading && !isPlaying
                        ? html`<span class="h-6 w-6 animate-spin rounded-full border-2 border-white/70 border-t-transparent"></span>`
                        : isPlaying
                        ? html`<${Pause} class="h-7 w-7" aria-hidden="true" />`
                        : html`<${Play} class="h-7 w-7" aria-hidden="true" />`
                    }
                  </button>
                  <div class="space-y-3">
                    <div class="flex flex-wrap items-center gap-3">
                      <span class="inline-flex items-center gap-1.5 rounded-full border border-emerald-400/30 bg-emerald-400/10 px-2 py-0.5 text-[0.6rem] font-semibold uppercase tracking-[0.25em] text-emerald-100">
                        <span class="relative flex h-1.5 w-1.5">
                          <span class="absolute inline-flex h-full w-full animate-ping rounded-full bg-emerald-100 opacity-75"></span>
                          <span class="relative inline-flex h-1.5 w-1.5 rounded-full bg-emerald-600"></span>
                        </span>
                        <${Activity} class="h-3 w-3" aria-hidden="true" />
                        <span class="sr-only">Flux audio actif</span>
                      </span>
                      ${(() => {
                        const statusLabel = statusConfig.label ?? statusConfig.srLabel;
                        if (!statusLabel) {
                          return null;
                        }
                        if (statusLabel.trim().toLowerCase() === 'en direct') {
                          return null;
                        }
                        return html`
                          <span class="rounded-full border border-white/10 bg-white/10 px-3 py-1 text-[0.7rem] font-medium uppercase tracking-[0.35em] text-slate-200">
                            ${statusConfig.Icon
                              ? html`<span class="flex items-center gap-1">
                                    <${statusConfig.Icon} class="h-3.5 w-3.5" aria-hidden="true" />
                                    <span>${statusLabel}</span>
                                  </span>`
                              : statusLabel}
                          </span>
                        `;
                      })()}
                      ${
                        isPlaying
                          ? html`<div class="audio-wave flex items-end gap-1 text-fuchsia-200">
                              <span class="h-4 bg-current"></span>
                              <span class="h-6 bg-current"></span>
                              <span class="h-5 bg-current"></span>
                              <span class="h-7 bg-current"></span>
                            </div>`
                          : null
                      }
                    </div>
                    <p class="text-sm text-slate-200">
                      Libre Antenne diffuse le salon vocal en continu. Branche-toi et profite du chaos.
                    </p>
                    <p class=${`text-xs font-medium ${hasError ? 'text-rose-200' : 'text-slate-300'}`}>${statusText}</p>
                  </div>
                </div>
              </div>
              <div class="relative w-full max-w-md rounded-2xl border border-white/10 bg-black/40 p-4 backdrop-blur">
                <div class="flex flex-wrap items-center justify-between gap-2 text-[0.65rem] uppercase tracking-[0.35em] text-slate-300">
                  <span class="rounded-full border border-fuchsia-400/30 bg-fuchsia-500/10 px-3 py-1 text-fuchsia-100">
                    ${streamInfo.format === 'mp3' ? 'MP3' : 'OPUS'}
                  </span>
                  <span class="truncate text-[0.6rem] text-slate-400">Endpoint : ${streamInfo.path}</span>
                </div>
                <div class="mt-4 flex items-center gap-3">
                  <button
                    type="button"
                    class="flex h-10 w-10 items-center justify-center rounded-full border border-white/10 bg-white/5 text-slate-200 transition hover:border-white/30 hover:bg-white/10 hover:text-white focus:outline-none focus:ring-2 focus:ring-fuchsia-300 focus:ring-offset-2 focus:ring-offset-slate-950"
                    aria-label=${isMuted || volume === 0 ? 'Activer le son' : 'Couper le son'}
                    onClick=${toggleMute}
                  >
                    ${renderVolumeIcon()}
                  </button>
                  <input
                    type="range"
                    min="0"
                    max="100"
                    step="1"
                    value=${Math.round(volume * 100)}
                    onInput=${handleVolumeChange}
                    class="h-1 flex-1 cursor-pointer appearance-none rounded-full bg-white/20 accent-fuchsia-400 focus:outline-none focus:ring-0"
                    aria-label="Volume"
                  />
                  <span class="w-12 text-right text-xs text-slate-300">${Math.round(volume * 100)}%</span>
                </div>
              </div>
            </div>
            ${
              hasError
                ? html`<div class="relative mt-5 flex flex-wrap items-center gap-3 rounded-2xl border border-rose-500/40 bg-rose-500/10 px-4 py-3 text-sm text-rose-100">
                    <div class="flex items-center gap-2 font-semibold">
                      <${AlertCircle} class="h-5 w-5" aria-hidden="true" />
                      Flux indisponible
                    </div>
                    <button
                      type="button"
                      class="inline-flex items-center gap-2 rounded-full border border-rose-200/40 bg-rose-200/10 px-3 py-1 text-[0.65rem] font-semibold uppercase tracking-[0.3em] text-rose-100 transition hover:bg-rose-200/20"
                      onClick=${handleRetry}
                    >
                      Relancer le flux
                      <${RefreshCcw} class="h-3.5 w-3.5" aria-hidden="true" />
                    </button>
                  </div>`
                : null
            }
            <audio ref=${audioRef} preload="auto" playsinline crossorigin="anonymous" aria-hidden="true" data-role="primary-stream"></audio>
          </div>
        `;
      };

      const HomePage = ({ status, lastUpdateLabel, streamInfo, audioKey, speakers, now, anonymousSlot }) => {
        const connectedCount = speakers.length;
        const activeSpeakersCount = speakers.reduce(
          (count, speaker) => count + (speaker?.isSpeaking ? 1 : 0),
          0,
        );

        return html`
          <${Fragment}>
          <section
            class="relative overflow-hidden rounded-3xl border border-white/10 bg-white/5 px-8 py-12 shadow-xl shadow-slate-950/50 backdrop-blur-xl"
          >
            <div class="pointer-events-none absolute -right-24 -top-24 h-64 w-64 rounded-full bg-fuchsia-500/25 blur-3xl"></div>
            <${StatusBadge}
              status=${status}
              className="absolute right-4 top-4 sm:right-6 sm:top-6"
            />
            <div class="relative flex flex-col gap-6 lg:flex-row lg:items-center lg:justify-between">
              <div class="space-y-4">
                <h1 class="text-4xl font-bold tracking-tight text-white sm:text-5xl">Libre Antenne</h1>
                <p class="max-w-xl text-base text-slate-200">
                  Le chaos en direct : un refuge sans filtre pour drogués, marginaux, alcooliques, gamers et esprits libres.
                </p>
                <a
                  class="inline-flex items-center gap-2 rounded-full border border-fuchsia-400/60 bg-fuchsia-500/20 px-5 py-2 text-sm font-semibold text-fuchsia-100 shadow-lg shadow-fuchsia-900/40 transition hover:bg-fuchsia-500/30 hover:text-white"
                  href="https://discord.gg/btjTZ5C"
                  target="_blank"
                  rel="noopener noreferrer"
                >
                  Rejoindre le Discord
                  <${ArrowRight} class="h-4 w-4" aria-hidden="true" />
                </a>
              </div>
              <div class="flex flex-col items-start gap-3 text-left lg:items-end lg:text-right">
                <p class="text-xs text-slate-300">Dernière mise à jour : ${lastUpdateLabel}</p>
              </div>
            </div>
          </section>

          <section class="relative overflow-hidden rounded-3xl border border-white/10 bg-white/5 p-8 backdrop-blur-xl">
            <div class="pointer-events-none absolute -right-20 bottom-0 h-56 w-56 rounded-full bg-indigo-400/30 blur-3xl"></div>
            <div class="relative flex flex-col gap-6 lg:flex-row lg:items-center lg:justify-between">
              <div class="space-y-2">
                <h2 class="text-2xl font-semibold text-white">Flux audio en direct</h2>
                <p class="text-sm text-slate-300">
                  Clique sur lecture si le flux ne démarre pas automatiquement. Volume conseillé : casque 💜
                </p>
              </div>
            </div>
            <${AudioPlayer} streamInfo=${streamInfo} audioKey=${audioKey} status=${status} />
          </section>

          <${AnonymousBooth} slot=${anonymousSlot} now=${now} />

          <section class="relative overflow-hidden rounded-3xl border border-white/10 bg-white/5 p-8 backdrop-blur-xl">
            <div class="flex flex-col gap-4 sm:flex-row sm:items-center sm:justify-between">
              <div>
                <h2 class="text-2xl font-semibold text-white">Intervenants en temps réel</h2>
                <p class="text-sm text-slate-300">
                  Toutes les personnes connectées au salon vocal apparaissent ici et l’animation se déclenche dès qu’une voix est détectée.
                </p>
              </div>
              <div class="flex items-center gap-3 rounded-full border border-white/10 bg-black/40 px-4 py-1.5 text-xs tracking-[0.3em] text-indigo-200">
                <span class="sr-only">Statistiques vocales</span>
                <span class="flex items-center gap-2">
                  <${Users} class="h-3.5 w-3.5" aria-hidden="true" />
                  <span aria-hidden="true" class="text-sm font-semibold tracking-normal">${connectedCount}</span>
                  <span aria-hidden="true" class="text-[0.6rem] font-semibold uppercase tracking-[0.35em] text-indigo-200/80">Co</span>
                  <span class="sr-only">personnes connectées</span>
                </span>
                <span aria-hidden="true" class="text-indigo-300">·</span>
                <span class="flex items-center gap-2">
                  <${Activity} class="h-3.5 w-3.5" aria-hidden="true" />
                  <span aria-hidden="true" class="text-sm font-semibold tracking-normal">${activeSpeakersCount}</span>
                  <span aria-hidden="true" class="text-[0.6rem] font-semibold uppercase tracking-[0.35em] text-indigo-200/80">Actifs</span>
                  <span class="sr-only">personnes actives</span>
                </span>
              </div>
            </div>
            <${SpeakersSection} speakers=${speakers} now=${now} />
          </section>
          </${Fragment}>
        `;
      };

      const AboutPage = () => html`
        <${Fragment}>
          <section class="space-y-6 rounded-3xl border border-white/10 bg-white/5 px-8 py-12 shadow-xl shadow-slate-950/40 backdrop-blur-xl">
            <p class="text-xs uppercase tracking-[0.35em] text-slate-300">Libre Antenne</p>
            <h1 class="text-4xl font-bold tracking-tight text-white sm:text-5xl">À propos de Libre Antenne</h1>
            <p class="text-base leading-relaxed text-slate-200">
              Libre Antenne est une zone franche où les voix prennent le pouvoir. Le flux est volontairement brut,
              capté en direct sur notre serveur Discord pour amplifier les histoires, les confidences et les improvisations qui
              naissent.
            </p>
            <p class="text-base leading-relaxed text-slate-200">
              Notre équipe façonne un espace accueillant pour les marginaux créatifs, les gamers insomniaques et toutes les
              personnes qui ont besoin d’un micro ouvert. Ici, aucune intervention n’est scriptée : la seule règle est de
              respecter la vibe collective et de laisser la spontanéité guider la conversation.
            </p>
          </section>

          <section class="grid gap-6 md:grid-cols-2">
            <div class="rounded-3xl border border-white/10 bg-slate-950/60 p-6 shadow-lg shadow-slate-950/40 backdrop-blur">
              <h2 class="text-xl font-semibold text-white">Un laboratoire</h2>
              <p class="mt-3 text-sm text-slate-300">
                Sessions freestyle, confessions lunaires, débats improvisés : chaque passage est un moment unique façonné par la
                communauté. Le direct nous permet de capturer cette énergie sans filtre.
              </p>
            </div>
            <div class="rounded-3xl border border-white/10 bg-slate-950/60 p-6 shadow-lg shadow-slate-950/40 backdrop-blur">
              <h2 class="text-xl font-semibold text-white">Technologie artisanale</h2>
              <p class="mt-3 text-sm text-slate-300">
                Notre mixeur audio fait circuler chaque voix avec finesse. Les outils open source et les contributions des
                membres permettent d’améliorer constamment la qualité du flux.
              </p>
            </div>
            <div class="rounded-3xl border border-white/10 bg-slate-950/60 p-6 shadow-lg shadow-slate-950/40 backdrop-blur">
              <h2 class="text-xl font-semibold text-white">Communauté inclusive</h2>
              <p class="mt-3 text-sm text-slate-300">
                Peu importe ton accent, ton parcours ou ton rythme de vie : tu es accueilli·e tant que tu joues collectif et que
                tu respectes les autres intervenants.
              </p>
            </div>
            <div class="rounded-3xl border border-white/10 bg-slate-950/60 p-6 shadow-lg shadow-slate-950/40 backdrop-blur">
              <h2 class="text-xl font-semibold text-white">Programmation souple</h2>
              <p class="mt-3 text-sm text-slate-300">
                Les créneaux sont ouverts : tu peux proposer un sujet, lancer un atelier ou simplement écouter. Le planning
                évolue selon les envies du moment.
              </p>
            </div>
          </section>

          <section class="rounded-3xl border border-fuchsia-500/30 bg-fuchsia-500/10 px-8 py-10 text-center shadow-xl shadow-fuchsia-900/30 backdrop-blur">
            <h2 class="text-2xl font-semibold text-white">Rejoins la fréquence</h2>
            <p class="mt-3 text-sm text-fuchsia-100">
              Connecte-toi sur Discord pour proposer ta voix, écouter les autres et faire grandir l’expérience Libre Antenne.
              La scène t’attend.
            </p>
            <a
              class="mt-6 inline-flex items-center gap-2 rounded-full border border-white/40 bg-white/10 px-5 py-2 text-sm font-semibold text-white transition hover:bg-white/20"
              href="https://discord.gg/btjTZ5C"
              target="_blank"
              rel="noopener noreferrer"
            >
              Rejoindre le Discord
              <${ArrowRight} class="h-4 w-4" aria-hidden="true" />
            </a>
          </section>
        </${Fragment}>
      `;

      const App = () => {
        const [status, setStatus] = useState('connecting');
        const [participantsMap, setParticipantsMap] = useState(() => new Map());
        const [streamInfo, setStreamInfo] = useState({ path: '/stream', format: 'opus', mimeType: 'audio/ogg' });
        const [lastUpdate, setLastUpdate] = useState(null);
        const [now, setNow] = useState(Date.now());
        const [menuOpen, setMenuOpen] = useState(false);
        const [route, setRoute] = useState(() => getRouteFromHash());
        const [anonymousSlot, setAnonymousSlot] = useState(() => normalizeAnonymousSlot());

        useEffect(() => {
          const id = setInterval(() => setNow(Date.now()), 1000);
          return () => clearInterval(id);
        }, []);

        useEffect(() => {
          if (!window.location.hash) {
            window.location.hash = '/';
          }
        }, []);

        useEffect(() => {
          const updateRoute = () => setRoute(getRouteFromHash());
          window.addEventListener('hashchange', updateRoute);
          return () => window.removeEventListener('hashchange', updateRoute);
        }, []);

        useEffect(() => {
          setMenuOpen(false);
        }, [route]);

        useEffect(() => {
          const source = new EventSource('/events');
          source.onopen = () => setStatus('connected');
          source.onerror = () => {
            if (source.readyState === EventSource.CONNECTING) {
              setStatus('reconnecting');
            } else if (source.readyState === EventSource.CLOSED) {
              setStatus('error');
            }
          };

          const applyState = (payload) => {
            if (!payload || typeof payload !== 'object') {
              return;
            }

            if (Array.isArray(payload.speakers)) {
              const next = new Map();
              for (const speaker of payload.speakers) {
                if (speaker?.id) {
                  next.set(speaker.id, {
                    ...speaker,
                    voiceState: speaker.voiceState ?? {},
                    isSpeaking: Boolean(speaker.isSpeaking),
                  });
                }
              }
              setParticipantsMap(next);
              setLastUpdate(Date.now());
            }

            if (Object.prototype.hasOwnProperty.call(payload, 'anonymousSlot')) {
              setAnonymousSlot(normalizeAnonymousSlot(payload.anonymousSlot));
            }
          };

          source.addEventListener('state', (event) => {
            try {
              const data = JSON.parse(event.data);
              applyState(data);
            } catch (err) {
              console.error('state event parse error', err);
            }
          });

          source.addEventListener('speaking', (event) => {
            try {
              const data = JSON.parse(event.data);
              if (data?.type === 'start' && data.user?.id) {
                setParticipantsMap((prev) => {
                  const next = new Map(prev);
                  const existing = next.get(data.user.id) || { voiceState: {} };
                  next.set(data.user.id, {
                    ...existing,
                    ...data.user,
                    isSpeaking: true,
                    voiceState: data.user.voiceState ?? existing.voiceState ?? {},
                  });
                  return next;
                });
              } else if (data?.type === 'end') {
                const targetId = data.user?.id ?? data.userId;
                if (targetId) {
                  setParticipantsMap((prev) => {
                    const next = new Map(prev);
                    const existing = next.get(targetId);
                    if (!existing) {
                      return prev;
                    }
                    const updated = {
                      ...existing,
                      ...data.user,
                      isSpeaking: false,
                      voiceState: (data.user && data.user.voiceState) ?? existing.voiceState ?? {},
                      lastSpokeAt: data.user?.lastSpokeAt ?? Date.now(),
                    };
                    next.set(targetId, updated);
                    return next;
                  });
                }
              }
              setLastUpdate(Date.now());
            } catch (err) {
              console.error('speaking event parse error', err);
            }
          });

          source.addEventListener('info', (event) => {
            try {
              const data = JSON.parse(event.data);
              setStreamInfo((prev) => ({
                path: data?.path ?? prev.path,
                format: data?.format ?? prev.format,
                mimeType: data?.mimeType ?? prev.mimeType,
              }));
            } catch (err) {
              console.error('info event parse error', err);
            }
          });

          source.addEventListener('anonymous-slot', (event) => {
            try {
              const data = JSON.parse(event.data);
              setAnonymousSlot(normalizeAnonymousSlot(data));
            } catch (err) {
              console.error('anonymous slot event parse error', err);
            }
          });

          return () => source.close();
        }, []);
        const speakers = useMemo(() => {
          const values = Array.from(participantsMap.values()).map((participant) => ({
            ...participant,
            voiceState: participant.voiceState ?? {},
          }));
          values.sort((a, b) => {
            const nameA = (a.displayName || a.username || '').trim();
            const nameB = (b.displayName || b.username || '').trim();
            const normalizedA = nameA.toLocaleLowerCase('fr-FR');
            const normalizedB = nameB.toLocaleLowerCase('fr-FR');
            const nameComparison = normalizedA.localeCompare(normalizedB, 'fr', {
              sensitivity: 'base',
            });
            if (nameComparison !== 0) {
              return nameComparison;
            }
            const idA = String(a.id ?? '');
            const idB = String(b.id ?? '');
            return idA.localeCompare(idB);
          });
          return values;
        }, [participantsMap]);

        const lastUpdateLabel = lastUpdate ? formatRelative(lastUpdate, now) : 'Synchronisation…';
        const audioKey = `${streamInfo.path}|${streamInfo.mimeType}`;

        const handleNavigate = (event, targetRoute) => {
          event.preventDefault();
          const targetHash = targetRoute === 'home' ? '#/' : '#/about';
          if (window.location.hash !== targetHash) {
            window.location.hash = targetHash;
          } else {
            setRoute(targetRoute);
          }
          setMenuOpen(false);
          window.scrollTo({ top: 0, behavior: 'smooth' });
        };

        return html`
          <div class="relative flex min-h-screen flex-col overflow-hidden">
            <div class="pointer-events-none absolute inset-0 overflow-hidden">
              <div class="absolute -left-24 -top-24 h-[24rem] w-[24rem] rounded-full bg-indigo-500/30 blur-3xl"></div>
              <div class="absolute -right-20 bottom-[-8rem] h-[28rem] w-[28rem] rounded-full bg-fuchsia-500/25 blur-[120px]"></div>
              <div class="absolute inset-0 bg-[radial-gradient(circle_at_top,_rgba(99,102,241,0.08)_0,_transparent_55%)]"></div>
            </div>
            <div class="relative z-10 flex flex-1 flex-col">
              <header class="sticky top-0 z-20 border-b border-white/10 bg-slate-950/70 backdrop-blur">
                <div class="mx-auto flex max-w-5xl items-center justify-between px-6 py-4 sm:px-10">
                  <a
                    href="#/"
                    class="text-base font-semibold uppercase tracking-[0.35em] text-slate-200 transition hover:text-white"
                    onClick=${(event) => handleNavigate(event, 'home')}
                  >
                    Libre Antenne
                  </a>
                  <nav class="hidden items-center gap-6 md:flex">
                    ${NAV_LINKS.map((link) =>
                      html`
                        <a
                          key=${link.route}
                          href=${link.hash}
                          onClick=${(event) => handleNavigate(event, link.route)}
                          aria-current=${route === link.route ? 'page' : undefined}
                          class=${`text-sm font-semibold transition hover:text-white ${
                            route === link.route ? 'text-white' : 'text-slate-300'
                          }`}
                        >
                          ${link.label}
                        </a>
                      `
                    )}
                  </nav>
                  <button
                    type="button"
                    class="inline-flex h-10 w-10 items-center justify-center rounded-full border border-white/20 bg-white/5 text-slate-200 transition hover:border-white/40 hover:text-white md:hidden"
                    aria-label=${menuOpen ? 'Fermer le menu' : 'Ouvrir le menu'}
                    aria-expanded=${menuOpen}
                    onClick=${() => setMenuOpen((prev) => !prev)}
                  >
                    ${
                      menuOpen
                        ? html`<${X} class="h-5 w-5" aria-hidden="true" />`
                        : html`<${Menu} class="h-5 w-5" aria-hidden="true" />`
                    }
                  </button>
                </div>
                ${
                  menuOpen
                    ? html`
                        <div class="border-t border-white/10 px-6 pb-6 pt-4 sm:px-10 md:hidden">
                          <nav class="flex flex-col gap-3">
                            ${NAV_LINKS.map((link) =>
                              html`
                                <a
                                  key=${`mobile-${link.route}`}
                                  href=${link.hash}
                                  onClick=${(event) => handleNavigate(event, link.route)}
                                  class=${`rounded-full border border-white/10 bg-white/5 px-4 py-2 text-sm font-semibold transition hover:bg-white/10 hover:text-white ${
                                    route === link.route ? 'text-white' : 'text-slate-200'
                                  }`}
                                >
                                  ${link.label}
                                </a>
                              `
                            )}
                          </nav>
                        </div>
                      `
                    : null
                }
              </header>

              <main class="flex-1 px-6 pb-16 pt-8 sm:px-10">
                <div class="mx-auto flex max-w-5xl flex-col gap-10">
                  ${
                    route === 'about'
                      ? html`<${AboutPage} />`
                      : html`<${HomePage}
                          status=${status}
                          lastUpdateLabel=${lastUpdateLabel}
                          streamInfo=${streamInfo}
                          audioKey=${audioKey}
                          speakers=${speakers}
                          now=${now}
                          anonymousSlot=${anonymousSlot}
                        />`
                  }
                </div>
              </main>

              <footer class="px-6 pb-10 text-center text-xs text-slate-500 sm:px-10">
                Libre Antenne · Tous droits réservés
              </footer>
            </div>
          </div>
        `;
      };
      render(html`<${App} />`, document.getElementById('app'));
    </script>
    <script>
      if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
          navigator.serviceWorker
            .register('/sw.js')
            .then((registration) => {
              console.info('Service worker enregistré', registration.scope);
            })
            .catch((error) => {
              console.warn('Service worker introuvable', error);
            });
        });
      }
    </script>
  </body>
</html>
